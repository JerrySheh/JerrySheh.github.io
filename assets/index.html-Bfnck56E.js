import{_ as n,c as e,f as a,o as i}from"./app-D22ydJtp.js";const l="/images/OS/process_status.png",p={};function t(d,s){return i(),e("div",null,s[0]||(s[0]=[a('<h1 id="程序的顺序执行和并发执行" tabindex="-1"><a class="header-anchor" href="#程序的顺序执行和并发执行"><span>程序的顺序执行和并发执行</span></a></h1><h2 id="顺序执行" tabindex="-1"><a class="header-anchor" href="#顺序执行"><span>顺序执行</span></a></h2><p>一个程序，通常由多个程序段组成。当前程序段执行结束之后，才运行后一程序段，这样的执行方式称为顺序执行。例如，输入 - 计算 - 输出，就是一个顺序执行的例子。</p><p>顺序执行的程序具有三个特征：顺序性，封闭性，可再现性。</p><h2 id="并发执行" tabindex="-1"><a class="header-anchor" href="#并发执行"><span>并发执行</span></a></h2><p>假设有三个设备，分别要进行 输入 - 计算 - 请求IO - 计算 - 输出。当 A 设备请求IO的时候，CPU 可以为 B 设备进行计算。这样的执行方式称为并发执行。</p><p>并发执行的程序具有三个特征：间断性、失去封闭性、不可再现性。</p><p>并发带来的程序不可再现性，是我们不希望出现的，因此我们要采取并发的控制。</p><hr><h1 id="进程的概念" tabindex="-1"><a class="header-anchor" href="#进程的概念"><span>进程的概念</span></a></h1><p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p><p>为了使并发执行的多个程序能独立地运行，操作系统提供了一个专门的数据结构，称为<code>进程控制块（Process Control Bolck, PCB）</code>。因此，进程实体（或者称进程映像）包括 PCB、程序段 和 数据段 三个部分。</p><p>值得注意的是，PCB是由OS进行管理的，进程本身无法操作其对应的PCB。</p><blockquote><p>一般来说，<strong>操作系统分配资源以进程为基本单位</strong>。但是在操作系统内核支持线程的情况下，调度是以线程为单位的。</p></blockquote><h2 id="进程的特征" tabindex="-1"><a class="header-anchor" href="#进程的特征"><span>进程的特征</span></a></h2><p>进程的特征有：<strong>动态性</strong>、<strong>并发行</strong>、<strong>独立性</strong>、<strong>异步性</strong>。</p><h2 id="进程的基本状态" tabindex="-1"><a class="header-anchor" href="#进程的基本状态"><span>进程的基本状态</span></a></h2><ul><li><p><strong>就绪（Ready）状态</strong>：万事俱备，只等CPU</p></li><li><p><strong>执行（Running）状态</strong>：获得CPU，正在执行</p></li><li><p><strong>阻塞（Block）状态</strong>： 发生某事件（例如IO请求）从而无法继续执行</p></li></ul><p>有时候，用户或者操作系统会将暂时不用的进程执行<code>挂起（suspend）</code>操作，这时候进程会进入挂起状态，表示该进程暂不接受调度。直至被重新<code>激活（active）</code>。</p><p><img src="'+l+`" alt="process_status"></p><p>除此之外，进程还有创建状态和终止状态。</p><p>当计算机系统没有用户进程执行时，处理机没有停止工作，而是执行 IDLE 程序。</p><hr><h1 id="进程控制" tabindex="-1"><a class="header-anchor" href="#进程控制"><span>进程控制</span></a></h1><p>进程控制主要包括创建新进程、终止已完成的进程、阻塞异常进程、转换进程状态等。</p><p>为了防止OS本身以及PCB等关键数据被应用程序破坏，处理机的执行状态分为<code>系统态（管态）</code>和<code>用户态（目态）</code>。系统态有较高的特权，能执行一切指令。用户态则只能访问特定寄存器和存储区。</p><p>OS的进程控制中，主要有三种支撑功能：中断处理、时钟管理、原语操作。</p><blockquote><p>所谓原语（Primitive），是由若干条指令组成的用于完成一定功能的一个过程。它是一种原子操作，不允许被中断。进程的原语操作有： CREATE、TERMINATION、BLOCK、WAKEUP、SUSPEND 和 ACTIVE。</p></blockquote><hr><h1 id="进程同步" tabindex="-1"><a class="header-anchor" href="#进程同步"><span>进程同步</span></a></h1><p>前面提到，并发执行带来的程序不可再现性，是我们不希望出现的，因此我们要采取并发的控制。我们用进程同步来解决这一问题。</p><h2 id="进程同步规则" tabindex="-1"><a class="header-anchor" href="#进程同步规则"><span>进程同步规则</span></a></h2><ul><li><strong>空闲让进</strong>：临界资源闲时，进程进入</li><li><strong>忙则等待</strong>：临界资源忙时，进程需等待</li><li><strong>有限等待</strong>：超时机制，避免死等</li><li><strong>让权等待</strong>：对不能进入临界区的进程，应立即释放处理机</li></ul><blockquote><p>基于这4个规则设计的进程同步机制，不会导致进程无限等待。</p></blockquote><h2 id="临界资源的概念" tabindex="-1"><a class="header-anchor" href="#临界资源的概念"><span>临界资源的概念</span></a></h2><p><code>临界资源（Critical Resource）</code>指的是一段时间内只允许一个进程访问的资源，只能够互斥访问。进程中访问互斥资源的那段代码称为<code>临界区</code>。</p><h2 id="信号量-semaphores-机制" tabindex="-1"><a class="header-anchor" href="#信号量-semaphores-机制"><span>信号量（Semaphores）机制</span></a></h2><p>信号量机制是1965年荷兰学者 Dijkstra 提出的一种进程同步工具。信号量可用于进程同步、进程互斥、控制进程的前驱关系。目前广泛用在单处理机、多处理机和计算机网络中。</p><p>在信号量机制中，分为 P操作 <code>wait(S)</code>（申请资源） 和 V操作 <code>signal(S)</code>（释放资源）。这是两个原子操作，在执行时是不可中断的。</p><h3 id="整形信号量" tabindex="-1"><a class="header-anchor" href="#整形信号量"><span>整形信号量</span></a></h3><p>整形信号量原型如下：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>wait(S){</span></span>
<span class="line"><span>  while (S&lt;=0); //do no-op</span></span>
<span class="line"><span>  S--</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>signal(S){</span></span>
<span class="line"><span>  S++;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即资源为0或者小于0时，进行等待。</p><p>但是这样会导致忙等，没有遵循让权等待的原则。于是又出现了记录型信号量。</p><h3 id="记录型信号量" tabindex="-1"><a class="header-anchor" href="#记录型信号量"><span>记录型信号量</span></a></h3><p>记录型信号量即是建立一个链表，让申请资源的进程进行排队。</p><p>原型如下：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  int value;</span></span>
<span class="line"><span>  struct Process_control_block *list;</span></span>
<span class="line"><span>}semaphore;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wait(semaphore *S){</span></span>
<span class="line"><span>  S-&gt;value--;</span></span>
<span class="line"><span>  if(S-&gt;value &lt; 0) block(S-&gt;list);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>signal(semaphore *S){</span></span>
<span class="line"><span>  S-&gt;value++;</span></span>
<span class="line"><span>  if(S-&gt;value &lt;=0) wakeup(S-&gt;list);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>S-&gt;value</code>的初始值表示系统中某类资源数目。</p><h3 id="and型信号量" tabindex="-1"><a class="header-anchor" href="#and型信号量"><span>AND型信号量</span></a></h3><p>假设 共享数据D 和 共享数据E 是可以被 进程A 和 进程B 访问的数据。</p><p>无论哪个进程，需要同时获得数据D和E后，方能进行操作。</p><p>那么，考虑以下情况：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>process A: wait(Dmutex)； // Dmutex = 0</span></span>
<span class="line"><span>process B: wait(Emutex)； // Dmutex = 0</span></span>
<span class="line"><span>process A: wait(Emutex)； // Dmutex = -1 阻塞</span></span>
<span class="line"><span>process B: wait(Dmutex)； // Dmutex = -1 阻塞</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，A获取了D资源， B获取了E资源， A想要再取得E资源才能进行操作，可是E资源在B那里，于是A进行阻塞等待。B想要再取得D资源才能进行操作，可是D资源在A那里，于是B也进行阻塞等待。</p><p>这样就造成了僵持状态，也就是<code>死锁</code>。</p><p>为了避免这种情况，我们可以用<code>AND同步机制</code>。其核心思想是：将进程在运行中需要的所有资源，一次性分配给该进程。</p><p>也就是说，要么一次性把 D资源和E资源 都分配给进程A，要么就都不分配。</p><h2 id="信号量的应用" tabindex="-1"><a class="header-anchor" href="#信号量的应用"><span>信号量的应用</span></a></h2><ul><li><strong>实现进程同步</strong></li><li><strong>实现进程互斥</strong></li><li><strong>实现前驱关系</strong></li></ul><hr><h1 id="经典进程同步问题" tabindex="-1"><a class="header-anchor" href="#经典进程同步问题"><span>经典进程同步问题</span></a></h1><h2 id="生产者-消费者问题" tabindex="-1"><a class="header-anchor" href="#生产者-消费者问题"><span>生产者-消费者问题</span></a></h2><p>定义变量</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>var mutex, empty, full = 1, n, 0</span></span>
<span class="line"><span>buffer:array[0...n-1] of item</span></span>
<span class="line"><span>in,out :Integer = 0, 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>mutex 用来加锁，某进程持有锁的时候其他进程不可进入</li><li>empty 表示缓存区可用空间，生产=往缓冲区放置，empty-1， 消费=从缓冲区读取，empty+1</li><li>full 表示可用产品，为0时消费者不可继续消费</li></ul><p>生产者进程</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>//process p</span></span>
<span class="line"><span>begin</span></span>
<span class="line"><span>    while(true):</span></span>
<span class="line"><span>        do begin</span></span>
<span class="line"><span>        produce nextp</span></span>
<span class="line"><span>        wait(empty)</span></span>
<span class="line"><span>        wait(mutex)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        buffer[in] = nextp</span></span>
<span class="line"><span>        in = (in + 1) mod n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        signal(mutex)</span></span>
<span class="line"><span>        signal(full)</span></span>
<span class="line"><span>    end</span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者进程</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>begin</span></span>
<span class="line"><span>    while(true):</span></span>
<span class="line"><span>        do begin</span></span>
<span class="line"><span>        wait(full)</span></span>
<span class="line"><span>        wait(mutex)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        nextp = buffer[out]</span></span>
<span class="line"><span>        out = (out + 1) mod n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        signal(mutex)</span></span>
<span class="line"><span>        signal(empty)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    end</span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="读者-写者问题" tabindex="-1"><a class="header-anchor" href="#读者-写者问题"><span>读者-写者问题</span></a></h2><p>定义变量</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>var rmutex, wmutex: Semaphores = 1, 1</span></span>
<span class="line"><span>    ReadCount: Integer = 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>rmutex表示读锁</li><li>wmutex表示写锁</li></ul><p>读者进程</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>begin</span></span>
<span class="line"><span>    while(true):</span></span>
<span class="line"><span>        wait(rmutex)    </span></span>
<span class="line"><span>        if ReadCount == 0 then wait(wmutex)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ReadCount++</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        signal(rmutex)</span></span>
<span class="line"><span>        // 读文件操作</span></span>
<span class="line"><span>        wait(rmutex)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        ReadCount--</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if ReadCount == 0 then signal(wmutex)</span></span>
<span class="line"><span>        signal(rmutex)</span></span>
<span class="line"><span>    end</span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写者进程</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>begin</span></span>
<span class="line"><span>    while(true):</span></span>
<span class="line"><span>        wait(wmutex)</span></span>
<span class="line"><span>        //写文件操作</span></span>
<span class="line"><span>        signal(wmutex)</span></span>
<span class="line"><span>    end</span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,78)]))}const r=n(p,[["render",t],["__file","index.html.vue"]]),o=JSON.parse('{"path":"/computer-system/wil41v61/","title":"操作系统漫游（二）进程","lang":"zh-CN","frontmatter":{"title":"操作系统漫游（二）进程","comments":true,"categories":"操作系统","tags":["操作系统"],"abbrlink":"be1528d7","createTime":"2018/03/17 10:15:50","permalink":"/computer-system/wil41v61/","description":"程序的顺序执行和并发执行 顺序执行 一个程序，通常由多个程序段组成。当前程序段执行结束之后，才运行后一程序段，这样的执行方式称为顺序执行。例如，输入 - 计算 - 输出，就是一个顺序执行的例子。 顺序执行的程序具有三个特征：顺序性，封闭性，可再现性。 并发执行 假设有三个设备，分别要进行 输入 - 计算 - 请求IO - 计算 - 输出。当 A 设备请...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/computer-system/wil41v61/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"操作系统漫游（二）进程"}],["meta",{"property":"og:description","content":"程序的顺序执行和并发执行 顺序执行 一个程序，通常由多个程序段组成。当前程序段执行结束之后，才运行后一程序段，这样的执行方式称为顺序执行。例如，输入 - 计算 - 输出，就是一个顺序执行的例子。 顺序执行的程序具有三个特征：顺序性，封闭性，可再现性。 并发执行 假设有三个设备，分别要进行 输入 - 计算 - 请求IO - 计算 - 输出。当 A 设备请..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jerrysheh.com/images/OS/process_status.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作系统漫游（二）进程\\",\\"image\\":[\\"https://jerrysheh.com/images/OS/process_status.png\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"顺序执行","slug":"顺序执行","link":"#顺序执行","children":[]},{"level":2,"title":"并发执行","slug":"并发执行","link":"#并发执行","children":[]},{"level":2,"title":"进程的特征","slug":"进程的特征","link":"#进程的特征","children":[]},{"level":2,"title":"进程的基本状态","slug":"进程的基本状态","link":"#进程的基本状态","children":[]},{"level":2,"title":"进程同步规则","slug":"进程同步规则","link":"#进程同步规则","children":[]},{"level":2,"title":"临界资源的概念","slug":"临界资源的概念","link":"#临界资源的概念","children":[]},{"level":2,"title":"信号量（Semaphores）机制","slug":"信号量-semaphores-机制","link":"#信号量-semaphores-机制","children":[{"level":3,"title":"整形信号量","slug":"整形信号量","link":"#整形信号量","children":[]},{"level":3,"title":"记录型信号量","slug":"记录型信号量","link":"#记录型信号量","children":[]},{"level":3,"title":"AND型信号量","slug":"and型信号量","link":"#and型信号量","children":[]}]},{"level":2,"title":"信号量的应用","slug":"信号量的应用","link":"#信号量的应用","children":[]},{"level":2,"title":"生产者-消费者问题","slug":"生产者-消费者问题","link":"#生产者-消费者问题","children":[]},{"level":2,"title":"读者-写者问题","slug":"读者-写者问题","link":"#读者-写者问题","children":[]}],"readingTime":{"minutes":6.27,"words":1882},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/computer-system/4.操作系统漫游（二）进程.md"}');export{r as comp,o as data};
