import{_ as r,c as d,a as i,b as s,d as l,e as n,f as t,r as p,o as h}from"./app-D22ydJtp.js";const o="/images/database/btree_index.jpg",g="/images/database/hash_index.jpg",k="/images/SQL/MyISAM_index.png",m="/images/SQL/InnoDB_index.png",y={};function b(u,e){const a=p("font");return h(),d("div",null,[e[29]||(e[29]=i("h1",{id:"什么是索引",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#什么是索引"},[i("span",null,"什么是索引？")])],-1)),i("p",null,[e[1]||(e[1]=s("索引是一个单独存储在磁盘上的数据结构，包含着对数据表里所有记录的引用指针。使用索引可以 ")),e[2]||(e[2]=i("strong",null,"提高数据库特定数据的查询速度",-1)),e[3]||(e[3]=s("。索引在存储引擎中实现，通常有 ")),e[4]||(e[4]=i("code",null,"BTree",-1)),e[5]||(e[5]=s(" 结构和 ")),e[6]||(e[6]=i("code",null,"Hash table",-1)),e[7]||(e[7]=s(" 结构，具体哪种和表的存储引擎有关。")),l(a,{color:"red"},{default:n(()=>e[0]||(e[0]=[s("MyISAM 和 InnoDB 只支持 BTree ")])),_:1}),e[8]||(e[8]=s("，MEMORY 同时支持 BTree 和 Hash table。"))]),e[30]||(e[30]=t('<hr><h1 id="为什么要用索引" tabindex="-1"><a class="header-anchor" href="#为什么要用索引"><span>为什么要用索引？</span></a></h1><p>优点：</p><ol><li>唯一索引可以保证数据库表中每行数据的唯一性</li><li>减少服务器需要扫描的数据量，加快数据的查询速度</li><li>加速表和表之间的连接</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li><li>将随机IO变为顺序IO</li></ol><p>缺点：</p><ol><li>创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加</li><li>索引需要占空间内存</li><li>在对表中数据进行增、删、改的时候，索引也需要动态维护，这样降低了数据维护速度</li></ol><hr><h1 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类"><span>索引的分类</span></a></h1><h2 id="按逻辑存储结构划分" tabindex="-1"><a class="header-anchor" href="#按逻辑存储结构划分"><span>按逻辑存储结构划分</span></a></h2><p>按逻辑存储结构划分，索引可以分为：</p><ol><li>B Tree索引</li><li>Hash索引</li><li>空间(Spatial)索引</li><li>全文(Fulltext)索引</li></ol><h3 id="_1-btree-索引" tabindex="-1"><a class="header-anchor" href="#_1-btree-索引"><span>1. BTree 索引</span></a></h3><p><img src="'+o+'" alt="btree_index"></p><p>InnoDB 和 MyISAM 底层都是基于 B+Tree 索引的。适用于 BTree 索引的情况有：</p><ol><li><strong>全值匹配</strong>：索引可能有多个列，全值匹配就是匹配所有的列。例如，查找姓名列为 Allen，年龄列为 18 的人。</li><li><strong>匹配最左前缀</strong>：匹配所有姓 Allen 的人。即只使用索引的第一列。</li><li><strong>匹配列前缀</strong>：匹配某一列的值的开头部分。例如姓以 Al 开头的人。也只使用了索引的第一列。</li><li><strong>匹配范围值</strong>：匹配查找姓在 Allen 和 Barrymore 之间的人。也只使用索引的第一列。</li><li><strong>精确匹配某一列并范围匹配另外一列</strong>：查找所有姓为 Allen，并且名字是 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</li><li><strong>只访问索引的查询</strong>：查询只需要访问索引，而无需访问数据行。（覆盖索引）</li></ol><p>不适用于 B Tree 索引的情况：</p><ol><li><strong>非最左</strong>：不是按照索引的最左列开始查找，就无法使用索引。例如无法查找姓氏（姓氏是索引的第一列）不知道，但名字（名字是索引第二列）为 Bill 的人。也无法查找姓氏最后以 n 结尾的人，因为姓氏虽然是第一列，但最左值不知道。</li><li><strong>跳过列</strong>：不能按索引查找姓氏为 “Smith”（第一列），名字（第二列）不知道，年龄为 18 （第三列）的人。如果非要这样查找，那MySQL只会用到第一列姓氏的索引。</li><li><strong>某个列存在范围</strong>：例如，姓氏为“Smith”，名字以“J”开头，年龄为18的SQL语句<code>... WHERE last_name = &#39;Smith&#39; AND first_name like &#39;J%&#39; AND age = 18;</code>，这时索引只有第一列姓氏起作用。</li></ol><h3 id="_2-hash索引" tabindex="-1"><a class="header-anchor" href="#_2-hash索引"><span>2.Hash索引</span></a></h3><p><img src="'+g+'" alt="hash_index"></p><p>Hash在理论上平均时间复杂度能达到O(1)，非常快，经常用在内存中。在数据库领域，数据更多的是放在磁盘中，Hash索引 跟 B tree索引 相比还是有一定的局限性，主要体现在：</p>',20)),i("ol",null,[i("li",null,[e[10]||(e[10]=s("Hash索引的无序性导致")),l(a,{color:"red"},{default:n(()=>e[9]||(e[9]=[s("无法范围查找")])),_:1}),e[11]||(e[11]=s("，像 ")),e[12]||(e[12]=i("code",null,">",-1)),e[13]||(e[13]=s("、")),e[14]||(e[14]=i("code",null,"<=",-1)),e[15]||(e[15]=s("、")),e[16]||(e[16]=i("code",null,"between",-1)),e[17]||(e[17]=s(" 等是无能为力的"))]),i("li",null,[e[19]||(e[19]=s("需要对完整的key计算Hash，因此")),l(a,{color:"red"},{default:n(()=>e[18]||(e[18]=[s("不支持部分匹配")])),_:1}),e[20]||(e[20]=s("。像 ")),e[21]||(e[21]=i("code",null,"like 'jerr%'",-1)),e[22]||(e[22]=s(" 这样的前缀匹配无能为力"))]),e[23]||(e[23]=i("li",null,"无法实现索引覆盖",-1)),e[24]||(e[24]=i("li",null,"Hash碰撞冲突代价高",-1))]),e[31]||(e[31]=t('<h3 id="_3-全文索引" tabindex="-1"><a class="header-anchor" href="#_3-全文索引"><span>3.全文索引</span></a></h3><p>简单地说，全文索引就是在一堆文字中，通过其中的某个关键字等信息，就能找到该字段所属的记录行。</p><ul><li><strong>注意</strong>：全文索引只有在 MyISAM 引擎上才能使用，且只能在CHAR,VARCHAR,TEXT类型字段上使用。</li></ul><h3 id="_4-空间索引" tabindex="-1"><a class="header-anchor" href="#_4-空间索引"><span>4.空间索引</span></a></h3><p>空间索引是对空间数据类型的字段建立的索引。</p><p>传统的索引不能很好的索引空间数据，我们需要一种方法能对空间数据进行索引，例如专门对地图上景点数据的索引，这就是空间索引。</p><p>MySQL中的空间数据类型有四种：</p><ul><li>GEOMETRY （几何体）</li><li>POINT （点）</li><li>LINESTRING （线）</li><li>POLYGON （多边形）</li></ul><p>在创建空间索引时，使用SPATIAL关键字。当引擎为MyISAM，创建空间索引的列，必须将其声明为 NOT NULL。</p><h2 id="按功能或约束划分" tabindex="-1"><a class="header-anchor" href="#按功能或约束划分"><span>按功能或约束划分</span></a></h2><h3 id="普通-单列-索引" tabindex="-1"><a class="header-anchor" href="#普通-单列-索引"><span>普通（单列）索引</span></a></h3><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> INDEX</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> indexName</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> ON</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> mytable(username(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">length</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p><h3 id="唯一索引" tabindex="-1"><a class="header-anchor" href="#唯一索引"><span>唯一索引</span></a></h3><p>索引列的值必须唯一，但允许有空值。如果要禁止空值，则成为主键索引。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">CREATE</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> UNIQUE INDEX</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> indexName</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> ON</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> mytable(username(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">length</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="主键索引" tabindex="-1"><a class="header-anchor" href="#主键索引"><span>主键索引</span></a></h3><p>主键索引是一种特殊的唯一索引，作用于主键。</p><p>特别注意：</p><ul><li>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</li><li>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</li></ul><h4 id="聚簇索引和二级索引的区别" tabindex="-1"><a class="header-anchor" href="#聚簇索引和二级索引的区别"><span>聚簇索引和二级索引的区别</span></a></h4><p>假设有数据行：</p><table><thead><tr><th>ID</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>500</td><td>Jerry</td><td>18</td></tr></tbody></table><p>age 列有普通索引，ID 列有主键索引</p><p>执行以下语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 18</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>首先会在 age 列索引找到 18，<strong>普通索引存储的是主键值</strong>，得到 ID 为 500 ，在根据 ID = 500 找到这一数据行的全部数据，这个过程叫回表。</p><p>而直接执行：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">select</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">where</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ID </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 500</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>直接通过聚簇索引找到 500 处，直接得到行数据。</p><h3 id="组合索引-多列索引" tabindex="-1"><a class="header-anchor" href="#组合索引-多列索引"><span>组合索引（多列索引）</span></a></h3><p>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则。</p><p>MySql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>当已经有一个 (a,b) 组合索引后，一般就不需要再建立 a 单列索引了。</p><p>组合索引有顺序性，建立组合索引时，是 (a,b) 还是 (b,a) ？ 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p><p>如果业务中既有 a, b 的组合查询， 也有 a, b 的单列查询，不得不维护两个索引时，是建立 (a,b) (b) 还是 (b,a) (a) 呢？ 考虑空间，在空间占用小的字段建立单列索引。</p><hr><h1 id="什么时候该创建索引" tabindex="-1"><a class="header-anchor" href="#什么时候该创建索引"><span>什么时候该创建索引？</span></a></h1><ol><li><strong>主键</strong>：对于主键，会自动建立一个唯一索引，以保证值唯一</li><li><strong>频繁查询</strong>：对于频繁查询的表或字段，建立索引无疑会提高查询效率</li><li><strong>查询中需要排序的字段</strong>：使用索引去访问排序字段将大大提高排序速度</li><li><strong>查询中需要统计或者分组字段</strong></li></ol><hr><h1 id="什么时候不该使用索引" tabindex="-1"><a class="header-anchor" href="#什么时候不该使用索引"><span>什么时候不该使用索引？</span></a></h1><ol><li>表记录太少</li><li>经常增删改的字段（因为修改字段的同时还要动态维护索引）</li><li>WHERE 条件用不到的字段不需要索引</li><li>过滤性（选择性）不好的字段不适合使用索引，例如0/1，男/女</li></ol><hr><h1 id="索引的底层实现" tabindex="-1"><a class="header-anchor" href="#索引的底层实现"><span>索引的底层实现</span></a></h1><h2 id="myisam-索引实现" tabindex="-1"><a class="header-anchor" href="#myisam-索引实现"><span>MyISAM 索引实现</span></a></h2>',45)),i("p",null,[e[26]||(e[26]=s("MyISAM 索引使用了 B+Tree 作为索引结构，叶子结点的 data 域")),l(a,{color:"red"},{default:n(()=>e[25]||(e[25]=[s("存放的是数据记录的地址")])),_:1}),e[27]||(e[27]=s("。MyISAM中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。主索引和辅助索引的存储结构没有任何区别。"))]),e[32]||(e[32]=i("p",null,[i("img",{src:k,alt:"MyISAM_index"})],-1)),e[33]||(e[33]=i("h2",{id:"innodb-索引实现",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#innodb-索引实现"},[i("span",null,"InnoDB 索引实现")])],-1)),e[34]||(e[34]=i("p",null,"虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。",-1)),l(a,{color:"red"},{default:n(()=>e[28]||(e[28]=[s("MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。 ")])),_:1}),e[35]||(e[35]=t('<h3 id="与-myisam-不同之处-聚簇索引" tabindex="-1"><a class="header-anchor" href="#与-myisam-不同之处-聚簇索引"><span>与 MyISAM 不同之处（聚簇索引）</span></a></h3><p>第一个与 MyISAM 不同的是 InnoDB 的数据文件本身就是索引文件。数据行放在索引的叶子叶，这种索引叫做聚簇索引。“聚簇”的意思是，数据行和相邻的键值紧凑地存储在一起。</p><p><img src="'+m+'" alt="InnoDB_index"></p><p>第二个与 MyISAM 的不同是 InnoDB 的二级索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p><p>因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM可以没有）。通常，InnoDB 被索引的列是主键列，因为 InnoDB 通过主键来聚集数据。如果没有定义主键，InnoDB会选择一个唯一的非空索引替代，如果表中没有这样的列，InnoDB 会隐式出定义一个主键来作为聚簇索引。</p><hr><h1 id="为什么聚簇索引要用-b-树-而不是b树" tabindex="-1"><a class="header-anchor" href="#为什么聚簇索引要用-b-树-而不是b树"><span>为什么聚簇索引要用 B+ 树，而不是B树？</span></a></h1><ol><li>B+树由于只在叶子节点有 data，单一节点比B树可以存储更多的元素，树更“矮胖”，查询的IO次数更少。</li><li>B树的节点既存放指针也存放数据，导致有些数据在树的“上面”而有些数据在树的“下面”，不利于范围查询。而B+树所有叶子节点形成有序链表，便于范围查询。</li></ol><ul><li>参考：<a href="https://blog.csdn.net/holmofy/article/details/80013034" target="_blank" rel="noopener noreferrer">MySQL性能优化[理论篇]-B树索引与hash索引</a></li></ul><hr><h1 id="选择合适的主键" tabindex="-1"><a class="header-anchor" href="#选择合适的主键"><span>选择合适的主键</span></a></h1><h2 id="自增主键" tabindex="-1"><a class="header-anchor" href="#自增主键"><span>自增主键</span></a></h2><p>由于聚簇索引底层由B+树组织，建议使用连续递增的数值作为主键（AUTO_INCREMENT是最好的）。相反，如果用无序的 UUID 作为主键，性能将非常糟糕。一个原因是UUID插入时不是在末尾追加的，需要维护树的结构，另一个原因是二级索引存放的是主键，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。UUID显然比数字主键要大。</p><p>在分布式情况下，常用 Twitter 开源的 Snowflake 雪花算法，在应用层生成主键。</p><h2 id="业务主键" tabindex="-1"><a class="header-anchor" href="#业务主键"><span>业务主键</span></a></h2><p>只有一个索引，且该索引必须是唯一索引的业务场景下，可以使用业务主键。（K-V场景）</p><hr><h1 id="什么时候索引会失效" tabindex="-1"><a class="header-anchor" href="#什么时候索引会失效"><span>什么时候索引会失效？</span></a></h1><p>索引可以包含多个列的值，但是列的顺序十分重要，MySQL只能高效地使用索引的最左前缀列。</p><ol><li>WHERE 条件有 不等于号</li><li>WHERE 条件使用了表达式或函数，如<code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></li><li>JOIN中，MySQL只有在 <strong>主键和外键的数据类型相同</strong> 时才能使用索引，否则无效</li><li><code>LIKE ‘abc%’</code>，MYSQL将使用索引；但 <code>LIKE ‘%abc’</code>，MySQL将不使用索引。</li><li>使用 OR 一般会使索引失效</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。</li></ol>',20))])}const A=r(y,[["render",b],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/db/s1hqhpop/","title":"MySQL索引","lang":"zh-CN","frontmatter":{"title":"MySQL索引","categories":["数据库","高性能MySQL"],"tags":["database"],"abbrlink":"a7354b8d","createTime":"2018/09/15 20:37:38","permalink":"/db/s1hqhpop/","description":"什么是索引？ 索引是一个单独存储在磁盘上的数据结构，包含着对数据表里所有记录的引用指针。使用索引可以 提高数据库特定数据的查询速度。索引在存储引擎中实现，通常有 BTree 结构和 Hash table 结构，具体哪种和表的存储引擎有关。，MEMORY 同时支持 BTree 和 Hash table。 为什么要用索引？ 优点： 唯一索引可以保证数据库表...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/db/s1hqhpop/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"MySQL索引"}],["meta",{"property":"og:description","content":"什么是索引？ 索引是一个单独存储在磁盘上的数据结构，包含着对数据表里所有记录的引用指针。使用索引可以 提高数据库特定数据的查询速度。索引在存储引擎中实现，通常有 BTree 结构和 Hash table 结构，具体哪种和表的存储引擎有关。，MEMORY 同时支持 BTree 和 Hash table。 为什么要用索引？ 优点： 唯一索引可以保证数据库表..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jerrysheh.com/images/database/btree_index.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"database"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL索引\\",\\"image\\":[\\"https://jerrysheh.com/images/database/btree_index.jpg\\",\\"https://jerrysheh.com/images/database/hash_index.jpg\\",\\"https://jerrysheh.com/images/SQL/MyISAM_index.png\\",\\"https://jerrysheh.com/images/SQL/InnoDB_index.png\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"按逻辑存储结构划分","slug":"按逻辑存储结构划分","link":"#按逻辑存储结构划分","children":[{"level":3,"title":"1. BTree 索引","slug":"_1-btree-索引","link":"#_1-btree-索引","children":[]},{"level":3,"title":"2.Hash索引","slug":"_2-hash索引","link":"#_2-hash索引","children":[]},{"level":3,"title":"3.全文索引","slug":"_3-全文索引","link":"#_3-全文索引","children":[]},{"level":3,"title":"4.空间索引","slug":"_4-空间索引","link":"#_4-空间索引","children":[]}]},{"level":2,"title":"按功能或约束划分","slug":"按功能或约束划分","link":"#按功能或约束划分","children":[{"level":3,"title":"普通（单列）索引","slug":"普通-单列-索引","link":"#普通-单列-索引","children":[]},{"level":3,"title":"唯一索引","slug":"唯一索引","link":"#唯一索引","children":[]},{"level":3,"title":"主键索引","slug":"主键索引","link":"#主键索引","children":[]},{"level":3,"title":"组合索引（多列索引）","slug":"组合索引-多列索引","link":"#组合索引-多列索引","children":[]}]},{"level":2,"title":"MyISAM 索引实现","slug":"myisam-索引实现","link":"#myisam-索引实现","children":[]},{"level":2,"title":"InnoDB 索引实现","slug":"innodb-索引实现","link":"#innodb-索引实现","children":[{"level":3,"title":"与 MyISAM 不同之处（聚簇索引）","slug":"与-myisam-不同之处-聚簇索引","link":"#与-myisam-不同之处-聚簇索引","children":[]}]},{"level":2,"title":"自增主键","slug":"自增主键","link":"#自增主键","children":[]},{"level":2,"title":"业务主键","slug":"业务主键","link":"#业务主键","children":[]}],"readingTime":{"minutes":10.2,"words":3059},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/db/2.MySQL/3.MySQL索引.md"}');export{A as comp,c as data};
