import{_ as s,c as a,f as e,o as t}from"./app-D22ydJtp.js";const n={};function l(h,i){return t(),a("div",null,i[0]||(i[0]=[e(`<blockquote><p>好的编程习惯：在首次使用的地方声明它。</p></blockquote><ol><li>如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。</li><li>如果变量需要在 <code>try-catch</code> 之外使用，那就必须在外面提前声明，这是一个例外。其他情况都应该遵循在首次使用的地方声明。</li><li>每个行为对应一个方法。保持方法小而集中。</li></ol><hr><h1 id="item-58-for-each-循环优于-for-i-循环" tabindex="-1"><a class="header-anchor" href="#item-58-for-each-循环优于-for-i-循环"><span>Item 58 for-each 循环优于 for-i 循环</span></a></h1><p>如果你只是需要容器里的元素，而不需要下标，for-i循环显然增加出错的可能性。最好用 for-each。for-each还可以用来遍历实现 Iterable 接口的任何对象。</p><p>但也有不能用for-each的情况：</p><ul><li><strong>过滤删除</strong>：如果需要遍历集合，并删除指定选元素，则需要使用显式iterator，以便可以调用其 remove 方法。 通常可以使用在 Java 8 中添加的 Collection 类中的 removeIf 方法，来避免显式遍历。</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> li</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Arrays</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">asList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">aa</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">bb</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">cc</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">li</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">removeIf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> a </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">aa</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">equals</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>转换</strong>：如果需要遍历一个列表或数组并替换其元素的部分或全部值，那么需要 iterator 或数组索引来替换元素的值。</li><li><strong>并行迭代</strong></li></ul><hr><h1 id="item-59-了解并使用库" tabindex="-1"><a class="header-anchor" href="#item-59-了解并使用库"><span>Item 59 了解并使用库</span></a></h1><blockquote><p>使用标准库，等于站在巨人肩膀上。</p></blockquote><p>例如，生成随机数，自己写有很大的不确定性，但是直接使用 <code>Random.nextInt(int)</code> 可以直接得到期望的结果。Java 7 更应该用 <code>ThreadLocalRandom</code>，它能产生更高质量的随机数，而且速度比<code>Random</code>快。对于 fork 连接池和并行流，使用 <code>SplittableRandom</code>。</p><p>每个程序员都应该熟悉 java.lang、java.util 和 java.io 的基础知识及其子包。其他库的知识可以根据需要学习。此外，Collections 框架和 Streams 库应该是每个程序员的基本工具包的一部分，<code>java.util.concurrent</code> 中的并发实用程序也应该是其中的一部分。</p><p>如果你在 Java 平台库中找不到你需要的东西，你的下一个选择应该是寻找高质量的第三方库，比如谷歌的优秀的开源 Guava 库 [Guava]。</p><p>不要重复造轮子！</p><hr><h1 id="item-60-精确数字就应避免-float-和-double-使用-bigdecimal" tabindex="-1"><a class="header-anchor" href="#item-60-精确数字就应避免-float-和-double-使用-bigdecimal"><span>Item 60 精确数字就应避免 float 和 double ，使用 BigDecimal</span></a></h1><p>《阿里巴巴Java开发手册》提到：</p><blockquote><p>【强制】小数类型为 decimal ，禁止使用 float 和 double 。 说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>float 和 double 类型特别不适合进行货币计算。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 输出：0.6100000000000001</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1.03</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0.42</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 BigDecimal 能解决这个问题，注意：<strong>使用 BigDecimal 的 String 构造函数而不是它的 double 构造函数</strong>。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">final</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> BigDecimal</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> TEN_CENTS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> BigDecimal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">.10</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">BigDecimal</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> funds</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> BigDecimal</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">1.00</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="item-61-基本数据类型优于包装类" tabindex="-1"><a class="header-anchor" href="#item-61-基本数据类型优于包装类"><span>Item 61 基本数据类型优于包装类</span></a></h1><p>基本数据类型和其包装类两者之间有真正的区别！！自动装箱和自动拆箱模糊了基本类型和包装类型之间的区别，但不会消除它们的区别。</p><ol><li>基本类型只有它们的值，而包装类型有方法，引用，对象。</li><li>基本类型只有值，而包装类型还能是 null。</li><li>基本类型比包装类型更节省时间和空间。</li></ol><p>如果你不小心的话，这三种差异都会给你带来真正的麻烦。例如，将 <code>==</code> 操作符应用于包装类型，这几乎都会带来错误。因为包装类同值可不同对象。</p><p>混合使用基本类型和包装类型，包装类型就会自动拆箱。如果一个空对象引用自动拆箱，将导致 <code>NullPointerException</code>。</p><p>还有一个问题，在 for 循环中声明包装类，可能会产生很多对象，或者反复装箱和拆箱，从而导致性能下降。</p><p>那什么时候应该用包装类呢？</p><ol><li><strong>作为集合中的元素、键和值</strong>：不能将基本类型放在集合中，因此必须使用包装类型。</li><li><strong>泛型</strong>：不能将变量声明为 <code>ThreadLocal&lt;int&gt;</code> 类型，只能用 <code>ThreadLocal&lt;Integer&gt;</code>。</li><li><strong>反射</strong>：在进行反射方法调用时，必须使用包装类型</li></ol><hr><h1 id="item-62-当使用其他类型更合适时应避免使用字符串" tabindex="-1"><a class="header-anchor" href="#item-62-当使用其他类型更合适时应避免使用字符串"><span>Item 62 当使用其他类型更合适时应避免使用字符串</span></a></h1><p>略</p><hr><h1 id="item-63-当心字符串连接引起的性能问题" tabindex="-1"><a class="header-anchor" href="#item-63-当心字符串连接引起的性能问题"><span>Item 63 当心字符串连接引起的性能问题</span></a></h1><p>不要使用 + 连接大量字符串，除非性能无关紧要。因为用 + 连接两个字符串时，本质上会复制这两个字符串的内容。一般这种需求最好使用 StringBuilder 的 append 方法。</p><hr><h1 id="item-64-通过接口引用对象" tabindex="-1"><a class="header-anchor" href="#item-64-通过接口引用对象"><span>Item 64 通过接口引用对象</span></a></h1><p>如果存在合适的接口类型，那么应该使用接口类型声明参数、返回值、变量和字段。除非具体类要使用的方法是接口没有的。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Good - uses interface as type</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Son</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> sonSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> LinkedHashSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Bad - uses class as type!</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">LinkedHashSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Son</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> sonSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> LinkedHashSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="item-65-接口优于反射" tabindex="-1"><a class="header-anchor" href="#item-65-接口优于反射"><span>Item 65 接口优于反射</span></a></h1><p>用反射调用方法比普通调用要慢得多，可能会造成性能损失。而且不能在编译时做类型检查。</p><p>通常在代码分析工具或依赖注入框架里会看到反射。仅仅在需要使用编译时不存在的类时才会用到反射。除此之外最好都用接口来声明类。</p><hr><h1 id="item-66-谨慎使用-native-方法" tabindex="-1"><a class="header-anchor" href="#item-66-谨慎使用-native-方法"><span>Item 66 谨慎使用 Native 方法</span></a></h1><p>JNI 允许 Java 程序调用本地方法，这些方法是用 C 或 C++ 等本地编程语言编写的。由于本地语言比 Java 更依赖于平台，因此使用本地方法的程序的可移植性较差，也更难调试。</p><hr><h1 id="item-67-谨慎优化" tabindex="-1"><a class="header-anchor" href="#item-67-谨慎优化"><span>Item 67 谨慎优化</span></a></h1><blockquote><p>编写好的程序，而不是快速的程序</p></blockquote><p>很多计算上的过失都被归昝于效率。不要去计较效率上的一些小小的得失，在 97% 的情况下，不成熟的优化才是一切问题的根源。​ —William A. Wulf [Wulf72] —Donald E. Knuth [Knuth74]</p><p>在优化方面，我们应该遵守两条规则：</p><ul><li>规则 1：不要进行优化。</li><li>规则 2 （仅针对专家）：还是不要进行优化，也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化。​ —M. A. Jackson [Jackson75]</li></ul><p>但是在设计系统时一定要考虑性能，特别是在设计API、线路层协议和持久数据格式时。</p><hr><h1 id="item-68-遵守被广泛认可的命名约定" tabindex="-1"><a class="header-anchor" href="#item-68-遵守被广泛认可的命名约定"><span>Item 68 遵守被广泛认可的命名约定</span></a></h1><p>参考《阿里巴巴Java开发手册》</p><table><thead><tr><th>Identifier Type</th><th>Example</th></tr></thead><tbody><tr><td>Package or module</td><td>org.junit.jupiter.api, com.google.common.collect</td></tr><tr><td>Class or Interface</td><td>Stream, FutureTask, LinkedHashMap,HttpClient</td></tr><tr><td>Method or Field</td><td>remove, groupingBy, getCrc</td></tr><tr><td>Constant Field、</td><td>MIN_VALUE, NEGATIVE_INFINITY</td></tr><tr><td>Local Variable</td><td>i, denom, houseNum</td></tr><tr><td>Type Parameter</td><td>T, E, K, V, X, R, U, V, T1, T2</td></tr></tbody></table><p>特别提一下容易被忽略的参数类型：T 表示任意类型，E 表示集合的元素类型，K 和 V 表示 Map 的键和值类型，X 表示异常。函数的返回类型通常为 R。任意类型的序列可以是 T、U、V 或 T1、T2、T3。</p>`,62)]))}const r=s(n,[["render",l],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/java/789gud1x/","title":"Effective Java（八）General Programming","lang":"zh-CN","frontmatter":{"title":"Effective Java（八）General Programming","comments":true,"abbrlink":"7d5810ff","createTime":"2019/11/25 21:55:19","categories":["Java","Effective Java"],"tags":["Java"],"permalink":"/java/789gud1x/","description":"好的编程习惯：在首次使用的地方声明它。 如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。 如果变量需要在 try-catch 之外使用，那就必须在外面提前声明，这是一个例外。其他情况都应该遵循在首次使用的地方声明。 每个行为对应一个方法。保持方法小而集中。 Item 58 for-each 循环优于 for-i ...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/java/789gud1x/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"Effective Java（八）General Programming"}],["meta",{"property":"og:description","content":"好的编程习惯：在首次使用的地方声明它。 如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。 如果变量需要在 try-catch 之外使用，那就必须在外面提前声明，这是一个例外。其他情况都应该遵循在首次使用的地方声明。 每个行为对应一个方法。保持方法小而集中。 Item 58 for-each 循环优于 for-i ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Effective Java（八）General Programming\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":6.09,"words":1828},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/java/2.effective java/8.Effective-Java（八）General-Programming.md"}');export{r as comp,d as data};
