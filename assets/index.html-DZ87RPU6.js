import{_ as h,c as p,a as i,b as a,d as n,e,f as l,r as k,o as r}from"./app-D22ydJtp.js";const d={};function g(o,s){const t=k("RouteLink");return r(),p("div",null,[s[8]||(s[8]=i("p",null,"Java 的 Lambda 表达式本质上就是一个匿名类。而什么是匿名类？就是在使用的时候现场 new 并实现的类。",-1)),i("p",null,[s[1]||(s[1]=a("只有一个方法的接口称为 ")),s[2]||(s[2]=i("strong",null,"函数式接口（functioning interface）",-1)),s[3]||(s[3]=a("，Lambda 表达式本质上就是对这样子的接口做现场实现。 可以参考我之前写的：")),n(t,{to:"/java/oclibm2w/"},{default:e(()=>s[0]||(s[0]=[a("Java简明笔记（八）Lambda和函数式编程")])),_:1})]),s[9]||(s[9]=l('<p>然而 lambda 也不是万能的，它只对函数是接口有用，如果一个接口有多个方法需要重写，那只能用匿名类。this 关键字在 lambda 中引用封闭实例，在匿名类中引用匿名类实例。如果你需要从其内部访问函数对象，则必须使用匿名类。</p><p>Lambdas 与匿名类都无法可靠地序列化和反序列化。因此，尽量少去 (如果有的话) 序列化一个 lambda (或一个匿名类实例)。如果有一个想要进行序列化的函数对象，比如一个 Comparator，那么使用一个私有静态嵌套类的实例（见 Item 24 ）。</p><p>作者建议：一行代码对于 lambda 说是理想的，三行代码是合理的最大值。 如果违反这一规定，可能会严重损害程序的可读性。</p><hr><h1 id="item-43-方法引用优于-lambda-表达式" tabindex="-1"><a class="header-anchor" href="#item-43-方法引用优于-lambda-表达式"><span>Item 43 方法引用优于 lambda 表达式</span></a></h1><p>lambda 比 匿名类 简洁，方法引用比 lambda 简洁。</p><p>考虑一个例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">merge</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> incr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> -&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> count </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> incr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第三个参数是一个 lambda，就只是求两数之和，而求和这个方法在 <code>Integer</code> 类中是存在的。所以可以直接用方法引用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">merge</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Integer</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">sum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>Method Ref Type</th><th>Example</th><th>Lambda Equivalent</th></tr></thead><tbody><tr><td>Static</td><td>Integer::parseInt</td><td>str -&gt; Integer.parseInt(str)</td></tr><tr><td>Bound</td><td>Instant.now()::isAfter</td><td>Instant then = Instant.now();t -&gt; then.isAfter(t)</td></tr><tr><td>Unbound</td><td>String::toLowerCase</td><td>str -&gt; str.toLowerCase()</td></tr><tr><td>Class</td><td>Constructor TreeMap&lt;K, V&gt;::new</td><td>() -&gt; new TreeMap&lt;K, V&gt;</td></tr><tr><td>Array</td><td>Constructor int[]::new</td><td>len -&gt; new int[len]</td></tr></tbody></table><p>原则：如果方法引用看起来更简短更清晰，请使用它们；否则，还是坚持 lambda。</p><hr><h1 id="item-44-优先使用标准的函数式接口" tabindex="-1"><a class="header-anchor" href="#item-44-优先使用标准的函数式接口"><span>Item 44 优先使用标准的函数式接口</span></a></h1><p>java 8 提供了很多标准函数式接口（<code>java.util.Function</code> 有 43 个接口），其中有 6 个基本接口。当我们编写函数对象时，应该优先考虑标准接口，而不是自己定义函数式接口。</p><table><thead><tr><th>接口</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>UnaryOperator&lt;T&gt;</td><td>T apply(T t)</td><td>String::toLowerCase</td></tr><tr><td>BinaryOperator&lt;T&gt;</td><td>T apply(T t1, T t2)</td><td>BigInteger::add</td></tr><tr><td>Predicate&lt;T&gt;</td><td>boolean test(T t)</td><td>Collection::isEmpty</td></tr><tr><td>Function&lt;T,R&gt;</td><td>R apply(T t)</td><td>Arrays::asList</td></tr><tr><td>Supplier&lt;T&gt;</td><td>T get()</td><td>Instant::now</td></tr><tr><td>Consumer&lt;T&gt;</td><td>void accept(T t)</td><td>System.out::println</td></tr></tbody></table>',16)),i("p",null,[s[5]||(s[5]=a("这 6 个标准接口接收相应不同的参数，返回相应不同的对象。参考：")),n(t,{to:"/java/oclibm2w/"},{default:e(()=>s[4]||(s[4]=[a("Java简明笔记（八）Lambda和函数式编程")])),_:1})]),s[10]||(s[10]=i("hr",null,null,-1)),s[11]||(s[11]=i("h1",{id:"item-45-使用-stream",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#item-45-使用-stream"},[i("span",null,"Item 45 使用 Stream")])],-1)),s[12]||(s[12]=i("p",null,"Java 8 提供了 Stream API，其中有两个关键抽象：流(Stream)表示有限或无限的数据元素序列，流管道(stream pipeline)表示对这些元素的多级计算。常见的流的来源包括集合，数组，文件，正则表达式模式匹配器，伪随机数生成器和其他流。流中的数据可以是引用对象，或 int，long 和 double 这三种基本数据类型。",-1)),s[13]||(s[13]=i("p",null,"流包括转换和规约，转换把一个流转换成另一个流，规约把流转换成非流（集合，数组，数字）。流是惰性计算的，遇到规约操作才会开始计算。",-1)),s[14]||(s[14]=i("p",null,"流虽然简化了代码，但过度使用流也可能使程序难于阅读和维护。最好是迭代跟流结合着使用。如果不确定一个任务是通过流还是迭代更好地完成，那么尝试这两种方法，看看哪一种效果更好。",-1)),i("p",null,[s[7]||(s[7]=a("关于流的用法，参考：")),n(t,{to:"/java/jj8zmrr8/"},{default:e(()=>s[6]||(s[6]=[a("Java简明笔记（九）Stream API")])),_:1})]),s[15]||(s[15]=l(`<hr><h1 id="item-46-优先考虑流中无副作用的函数" tabindex="-1"><a class="header-anchor" href="#item-46-优先考虑流中无副作用的函数"><span>Item 46 优先考虑流中无副作用的函数</span></a></h1><p>流不仅仅是一个 API，它是函数式编程的范式（paradigm）。函数式编程应该尽可能使用纯函数（pure function）。纯函数的结果仅取决于其输入，不依赖于任何可变状态，也不更新任何状态。为此，传递给流操作的任何函数对象（中间操作和终结操作）都应该没有副作用。</p><p>一个建议是 forEach 操作应仅用于报告流计算的结果，而不是用于执行计算。考虑下面的代码，它只是伪装成流代码的迭代代码，并没有享受到流带来的好处。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Uses the streams API but not the paradigm--Don&#39;t do this!</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> Long</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> freq</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> HashMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Stream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> words</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Scanner</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">file</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tokens</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    words</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">forEach</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">word </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        freq</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">merge</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">word</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toLowerCase</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(),</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1L</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Long</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">sum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    });</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好的做法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Proper use of streams to initialize a frequency table</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> Long</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> freq</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Stream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> words</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Scanner</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">file</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tokens</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    freq </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> words</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        .</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">collect</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">groupingBy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">toLowerCase</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> counting</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()));</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="item-47-优先使用-collection-而不是-stream-来作为方法的返回类型" tabindex="-1"><a class="header-anchor" href="#item-47-优先使用-collection-而不是-stream-来作为方法的返回类型"><span>Item 47 优先使用 Collection 而不是 Stream 来作为方法的返回类型</span></a></h1><p>如果在返回一些序列元素的方法里返回了一个流，而你想迭代，（或相反），可以用适配器将流和 iterator 互相转换。但这样会降低效率。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Adapter from  Stream&lt;E&gt; to Iterable&lt;E&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Iterable</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> iterableOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Stream</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> stream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> stream</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">iterator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// Adapter from Iterable&lt;E&gt; to Stream&lt;E&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Stream</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> streamOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Iterable</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">E</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> iterable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> StreamSupport</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">stream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">iterable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">spliterator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(),</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，最好优先考虑返回集合，而不是返回一个流。如果返回集合是不可行的，则返回流或可迭代对象。</p><hr><h1 id="item-48-谨慎使用流并行" tabindex="-1"><a class="header-anchor" href="#item-48-谨慎使用流并行"><span>Item 48 谨慎使用流并行</span></a></h1><p>让我们回顾一下java的并发历史： 1996 年 java 发布 1.0 时就内置了对线程的支持，包括同步和 wait / notify 机制，java 5 加入了 <code>java.util.concurrent</code> 类库，提供了并发集合和执行器框架。Java 7 引入了 fork-join 包，这是一个用于并行分解的高性能框架。 Java 8 引入了流，可以通过对 parallel 方法的单个调用来并行化。用 Java 编写并发程序变得越来越容易，但编写正确快速的并发程序还像以前一样困难。</p><p>通常，并行在 ArrayList、HashMap、HashSet 和 ConcurrentHashMap 实例、数组、int 类型和 long 类型的流上性能提升是最好的。因为它们都可以精确而廉价地分割成任意大小的子程序。</p><p>Java 8 的 parallel 本质上是 fork-join 的封装，适合用少量线程执行大量任务的情况。本质上，是通过分治归并实现并行的。但这并不适合所有情况。只有在充分测试确实没有安全隐患和性能问题时，才考虑使用 parallel 。</p>`,17))])}const m=h(d,[["render",g],["__file","index.html.vue"]]),A=JSON.parse('{"path":"/java/72o73ujp/","title":"Effective Java（六）Lambdas and Streams","lang":"zh-CN","frontmatter":{"title":"Effective Java（六）Lambdas and Streams","comments":false,"categories":["Java","Effective Java"],"tags":["Java"],"abbrlink":"cc85a16e","createTime":"2019/11/19 22:39:14","permalink":"/java/72o73ujp/","description":"Java 的 Lambda 表达式本质上就是一个匿名类。而什么是匿名类？就是在使用的时候现场 new 并实现的类。 只有一个方法的接口称为 函数式接口（functioning interface），Lambda 表达式本质上就是对这样子的接口做现场实现。 可以参考我之前写的： 然而 lambda 也不是万能的，它只对函数是接口有用，如果一个接口有多个方...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/java/72o73ujp/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"Effective Java（六）Lambdas and Streams"}],["meta",{"property":"og:description","content":"Java 的 Lambda 表达式本质上就是一个匿名类。而什么是匿名类？就是在使用的时候现场 new 并实现的类。 只有一个方法的接口称为 函数式接口（functioning interface），Lambda 表达式本质上就是对这样子的接口做现场实现。 可以参考我之前写的： 然而 lambda 也不是万能的，它只对函数是接口有用，如果一个接口有多个方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Effective Java（六）Lambdas and Streams\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":5.53,"words":1659},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/java/2.effective java/6.Effective-Java（六）Lambdas-and-Streams.md"}');export{m as comp,A as data};
