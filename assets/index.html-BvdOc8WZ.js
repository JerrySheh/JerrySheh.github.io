import{_ as t,c as n,f as i,o}from"./app-D22ydJtp.js";const a="/images/TCPconnection.png",l="/images/TCP3wayhandshake.png",r="/images/TCPsegment.png",s="/images/networking/tcp.jpg",c={};function p(d,e){return o(),n("div",null,e[0]||(e[0]=[i('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>前面两篇介绍 Socket 的文章中，简单描述了 Socket 网络编程的过程。这一篇，主要介绍一下 TCP 的工作原理。包含以下六点：</p><ol><li>TCP连接简介</li><li>TCP报文段</li><li>连接的建立和断开（三次握手，四次挥手）</li><li>TCP可靠在哪里（序号、ACK回复、超时重传）</li><li>滑窗机制</li><li>拥塞控制机制</li></ol><hr><h2 id="一、tcp连接简介" tabindex="-1"><a class="header-anchor" href="#一、tcp连接简介"><span>一、TCP连接简介</span></a></h2><p>TCP 全称 Transmission Control Protocol，传输控制协议，是传输层的协议。它的任务是将应用层的数据准确地交付给网络层。</p><p>两个应用程序，如果用TCP来发送数据，那么他们必须先互相“握手”。也就是说，在正式传数据之前，要先互相发送一些预备报文段，以建立确保数据传输的参数。所以我们说，<strong>TCP是面向连接的(connection-oriented)，也是可靠的传输</strong>。</p><p>虽然TCP是面向连接的，但是这种“连接”，不是端到端线路意义上的连接，也不是虚电路。TCP的连接，是保留在两个端系统的状态当中的。因此，中间路由器对TCP连接是视而不见的。</p><p>TCP提供的是<code>全双工服务</code>，数据可以从A到B，也能从B到A。同时，TCP是<code>点对点</code>的，TCP连接是单个发送方与单个接收方之间的连接，不能多播。（但这并不代表一个服务器不能与多个客户端建立连接，只是说，一个连接只能在两台主机之间，如果一台主机要接收另外两台主机的数据，需要为那两台主机分别建立TCP连接）</p><p><img src="'+a+'" alt="TCPconnection"></p><h3 id="tcp是怎样建立连接的-三次握手" tabindex="-1"><a class="header-anchor" href="#tcp是怎样建立连接的-三次握手"><span>TCP是怎样建立连接的（三次握手）？</span></a></h3><ol><li>首先，客户端先发送一个特殊的TCP报文段</li><li>服务器返回另一个特殊的报文段响应</li><li>客户端用第三个特殊报文段作为响应</li></ol><p>前两个报文段，不承载“有效载荷”（不包含应用层的数据），仅仅是打招呼。后一个报文段，可以承载有效载荷。由于在这两台主机之间发送了 3 个报文段，所以这种连接建立的过程，我们称之为“三次握手”，稍后我们详细讨论。</p><p><img src="'+l+'" alt="TCP3wayhandshake"></p><hr><h2 id="二、tcp报文段" tabindex="-1"><a class="header-anchor" href="#二、tcp报文段"><span>二、TCP报文段</span></a></h2><p>TCP将应用程序的报文（message）分组，再为每个分组加上<code>TCP首部</code>，形成多个<code>TCP报文段（TCP segment）</code>，再下传给网络层。报文段的首部如下图：</p><p><img src="'+r+'" alt="TCPsegment"></p><p>首部包含了以下信息：</p><ol><li><strong>源端口号（source port）</strong> 和 <strong>目的端口号(destination port)</strong> ：各16位，因为16位最大能表示的数字是65535，所以端口号最大值也只能是65535。</li><li><strong>序号字段(sequence number field)</strong> ：32位，用来实现可靠数据传输，例如一个500000字节的文件被分为500个TCP报文段，初始序号可以随意指定，后续的序号是前面序号+携带的字节数，例如初始序号79，每个报文段携带1000字节，第二个序号就是1079</li><li><strong>确认号字段(Acknowledgement number field)</strong> ：32位，也是用来实现可靠数据传输，表示期望对方发送的下一字节的序号</li><li><strong>接收窗口字段(receive windows field)</strong> ：16位，用于流量控制，表示接收方愿意接受的字节数量</li><li><strong>首部长度字段(header length field)</strong> ：4位，TCP的首部长度是可变的，这个字段表示首部长度</li><li><strong>选项字段(options field)</strong> ：不定位数，用作窗口调节因子</li><li><strong>标志字段(flag field)</strong> ：6位，包括ACK、RST、SYN、FIN、PSH、URG，各占1位</li></ol><p>我们主要关注三个点：</p><ol><li>一个TCP头部需要包含出发端口和目的地端口。这些与IP头中的两个IP地址共同确定了连接。</li><li>每个TCP片段都有序号。这些序号最终将数据部分的文本片段整理成为文本流。</li><li>只有标志字段的ACK位设定的时候，确认号字段才有效。ACK确认号说明了接收方期待接收的下一个片段，所以ACK确认号为最后接收到的片段序号加1。</li></ol><hr><h2 id="三、tcp连接的建立和断开" tabindex="-1"><a class="header-anchor" href="#三、tcp连接的建立和断开"><span>三、TCP连接的建立和断开</span></a></h2><h3 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手</span></a></h3><p>前面提到，TCP建立连接的过程称为三次握手。其详细过程如下：</p><ol><li><strong>第一步</strong>：客户端先发送一个特殊的TCP报文段，不包含应用层数据。但首部标志字段的SYN位被置为1（称为SYN报文段），并随机指定一个初始序号（seq）。（为什么初始序号要随机，主要是安全方面考虑）。</li><li><strong>第二步</strong>：服务器收到客户端的SYN报文段后，就会为该TCP连接分配TCP缓存和变量，并回复一个报文段（称为SYNACK报文段）。在这个回复报文段里，SYN位也是被置为1，确认号ack置为客户端刚刚发来的初始序号seq+1，并随机指定一个自己的初始序号seq。</li><li><strong>第三步</strong>：客户端收到服务器的SYNACK报文段后，在客户端为该TCP连接分配缓存和变量，同时也回复了一个报文段，此时连接已经建立，所以SYN置为0，ACK确认号为服务器的初始序号seq+1，seq为自己第一步的seq+1</li></ol><h3 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手</span></a></h3><p>当TCP连接的任意一方想断开连接时，将会发起断开信号，连接结束后，主机里的TCP连接资源（缓存和变量）随即被释放。断开的过程需要通信四次，所以称为四次挥手。其详细过程如下：</p><ol><li><strong>第一步</strong>：客户端发起关闭连接命令。此时会向服务器发送一个特殊的报文段，标志字段的<code>FIN</code>位被置为<code>1</code>，随后客户端进入 <code>FIN_WAIT_1</code> 状态，该状态表示客户端正在等待服务器的ACK确认。</li><li><strong>第二步</strong>：服务器收到这个特殊的报文段后，回复一个确认报文段，收到这个确认报文段后，客户端进入 <code>FIN_WAIT_2</code> 状态，该状态表示客户端期望收到服务器的可以终止命令。</li><li><strong>第三步</strong>：稍后，服务器也向客户端发起一个<code>FIN</code>位为<code>1</code>的特殊报文段，表示可以终止。</li><li><strong>第四步</strong>：客户端回复一个确认报文段进行确认，之后进入 <code>TIME_WAIT</code> 状态等待30秒（目的是确认报文若丢失可以重传），之后连接断开。</li></ol><p><img src="'+s+'" alt="tcp"></p><hr><h2 id="四、tcp-为何可靠" tabindex="-1"><a class="header-anchor" href="#四、tcp-为何可靠"><span>四、TCP 为何可靠</span></a></h2><h3 id="流-和次序" tabindex="-1"><a class="header-anchor" href="#流-和次序"><span>“流”和次序</span></a></h3><p>我们之前提到，Linux的哲学是“一切皆文件”，一切都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”的模式来操作。计算机程序之间的通信，是一个进程写入文本流(byte stream)，而另一个进程读取这个流。<strong>TCP协议虚拟了文本流的通信</strong>。</p><p>要知道，在两台相隔很远的主机中，隔着许许多多的路由器和交换机，因此数据发送的时候，先发的数据可能会后到。好在TCP协议确保了数据到达的顺序与文本流顺序相符。这就是为什么TCP报文段里面需要有序号的原因。TCP接收方将接收到的许许多多报文段按照序号排列起来，组成原始数据。</p><h3 id="收到请回复" tabindex="-1"><a class="header-anchor" href="#收到请回复"><span>“收到请回复”</span></a></h3><p>TCP为什么需要确认号呢？我们知道，TCP是全双工的协议，在A主机向B主机发送数据的同时，B主机也能向A主机发送数据（在同一个TCP连接中）。例如，A向B发送8字节数据时携带了序号，seq=79，B向A发数据时也需要携带一个序号seq=45，同时，“回复”确认收到了A主机seq=79的序号，并期望接收A主机seq=87（为什么不是80，因为前一个序号有8字节）的序号，所以就有了确认号ack=87。</p><p>也就是说，TCP发送方每发送一个报文段，接收方都会回复一个确认号。以确保这个片段收到了。比如已经接收到了片段1，片段2，片段3，那么接收方就开始期待片段4。值得注意的是，如果此时收到了片段5 片段6，也不会丢弃，会暂时存起来，等到片段4到达再拼接，但是如果此时收到了片段9，那么接收方就可能拒绝接收了。</p><h3 id="报文段丢了-重发" tabindex="-1"><a class="header-anchor" href="#报文段丢了-重发"><span>报文段丢了，重发</span></a></h3><p>IP协议是不可靠的，也就是说，交付给网络层的报文段，可能会传着传着就丢了。那咋办？ TCP有一个定时器超时，规定如果一段时间之后，还没有收到接收方的确认（ACK），就默认这个报文段丢了。就会重新发一个过去，直到接收方回复确认收到。</p><p>那么，如果说，这个报文段发过去了，接收方也接收到了。接收方返回给发送方的“确认”信息丢了，怎么办呢？ 这种情况下，发送方依然会重发。 接收方一看，咦你居然发了两个一样的报文段？就会自动丢弃其中的一个了，当然，还要给发送方再发一次“收到”回复，以免发送方孜孜不倦、不辞劳苦地一直重发、一直重发。</p><hr><h2 id="五、滑窗" tabindex="-1"><a class="header-anchor" href="#五、滑窗"><span>五、滑窗</span></a></h2><p>我们已经知道，TCP发送方片段1发出去，接收方回复ACK已收到1，发送方再发片段2，接收方再回复ACK已收到2......</p><p>在这种模式下，发送方保持发送-&gt;等待ACK-&gt;发送-&gt;等待ACK...的状态，虽然很“可靠”，但是效率太慢了。为了提高效率，同时发多个片段，又怕后发的先到了，怎么办呢？</p><p>我们可以这么做：利用缓存保留一些“不那么乱”的片段，期望能在短时间内补充上之前的片段(暂不处理，但发送相应的ACK)；对于“乱”的比较厉害的片段，则将它们拒绝(不处理，也不发送对应的ACK)。</p><p>滑窗(sliding window)被同时应用于接收方和发送方，以解决以上问题。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示TCP正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。滑窗越大，越大的滑窗同时处理的片段数目越多(当然，计算机也必须分配出更多的缓存供滑窗使用)。</p><p>TCP有专门的算法动态调整滑窗的大小。</p><hr><h2 id="六、tcp拥塞控制" tabindex="-1"><a class="header-anchor" href="#六、tcp拥塞控制"><span>六、TCP拥塞控制</span></a></h2><p>在TCP协议中，我们使用<code>连接</code>记录TCP两端的状态，使用<code>序号和分段</code>保证了TCP传输的有序，使用<code>滑窗</code>（中的某些机制）来实现发送方和接收方处理能力的匹配，并使用<code>重复发送</code>来实现TCP传输的可靠性。</p><p>一切看似都很美好，但是，随着互联网的发展，越来越多的主机之间要相互发送数据，有时候中间路由器会处理不过来从而发生丢包，一丢包，这些基于TCP的主机就又重新发送，路由器不堪重负，就会发生更严重的丢包，构成了一个恶性循环。这称为堵塞崩溃。</p><p>因此，为了避免发送堵塞崩溃，TCP加入了<code>拥塞控制机制</code>。当TCP发送方探测到网络拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况。</p><h3 id="如何探测网络拥堵" tabindex="-1"><a class="header-anchor" href="#如何探测网络拥堵"><span>如何探测网络拥堵</span></a></h3><p>当发生ACK超时和重复ACK。发送方就认为TCP片段丢失，则认为网络中出现堵塞。</p><h3 id="如何控制速率" tabindex="-1"><a class="header-anchor" href="#如何控制速率"><span>如何控制速率</span></a></h3><p>TCP协议通过控制滑窗(sliding window)大小来控制发送速率。在TCP滑窗管理中，有一个窗口限制，就是advertised window size，以实现TCP流量控制。TCP还会维护一个congestion window size，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)。</p><p>（TCP拥塞控制和滑窗的内容来自<a href="http://www.cnblogs.com/vamei/archive/2012/12/18/2822739.html" target="_blank" rel="noopener noreferrer">vamei的博客</a>，vamei写得太好了，值得好好学习）</p>',59)]))}const C=t(c,[["render",p],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/networking/4cfyabo6/","title":"TCP之旅","lang":"zh-CN","frontmatter":{"title":"TCP之旅","categories":"计算机网络","tags":["计算机网络"],"abbrlink":"e997edc6","createTime":"2017/12/08 00:11:39","permalink":"/networking/4cfyabo6/","description":"前言 前面两篇介绍 Socket 的文章中，简单描述了 Socket 网络编程的过程。这一篇，主要介绍一下 TCP 的工作原理。包含以下六点： TCP连接简介 TCP报文段 连接的建立和断开（三次握手，四次挥手） TCP可靠在哪里（序号、ACK回复、超时重传） 滑窗机制 拥塞控制机制 一、TCP连接简介 TCP 全称 Transmission Cont...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/networking/4cfyabo6/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"TCP之旅"}],["meta",{"property":"og:description","content":"前言 前面两篇介绍 Socket 的文章中，简单描述了 Socket 网络编程的过程。这一篇，主要介绍一下 TCP 的工作原理。包含以下六点： TCP连接简介 TCP报文段 连接的建立和断开（三次握手，四次挥手） TCP可靠在哪里（序号、ACK回复、超时重传） 滑窗机制 拥塞控制机制 一、TCP连接简介 TCP 全称 Transmission Cont..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jerrysheh.com/images/TCPconnection.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP之旅\\",\\"image\\":[\\"https://jerrysheh.com/images/TCPconnection.png\\",\\"https://jerrysheh.com/images/TCP3wayhandshake.png\\",\\"https://jerrysheh.com/images/TCPsegment.png\\",\\"https://jerrysheh.com/images/networking/tcp.jpg\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"一、TCP连接简介","slug":"一、tcp连接简介","link":"#一、tcp连接简介","children":[{"level":3,"title":"TCP是怎样建立连接的（三次握手）？","slug":"tcp是怎样建立连接的-三次握手","link":"#tcp是怎样建立连接的-三次握手","children":[]}]},{"level":2,"title":"二、TCP报文段","slug":"二、tcp报文段","link":"#二、tcp报文段","children":[]},{"level":2,"title":"三、TCP连接的建立和断开","slug":"三、tcp连接的建立和断开","link":"#三、tcp连接的建立和断开","children":[{"level":3,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[]},{"level":3,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[]}]},{"level":2,"title":"四、TCP 为何可靠","slug":"四、tcp-为何可靠","link":"#四、tcp-为何可靠","children":[{"level":3,"title":"“流”和次序","slug":"流-和次序","link":"#流-和次序","children":[]},{"level":3,"title":"“收到请回复”","slug":"收到请回复","link":"#收到请回复","children":[]},{"level":3,"title":"报文段丢了，重发","slug":"报文段丢了-重发","link":"#报文段丢了-重发","children":[]}]},{"level":2,"title":"五、滑窗","slug":"五、滑窗","link":"#五、滑窗","children":[]},{"level":2,"title":"六、TCP拥塞控制","slug":"六、tcp拥塞控制","link":"#六、tcp拥塞控制","children":[{"level":3,"title":"如何探测网络拥堵","slug":"如何探测网络拥堵","link":"#如何探测网络拥堵","children":[]},{"level":3,"title":"如何控制速率","slug":"如何控制速率","link":"#如何控制速率","children":[]}]}],"readingTime":{"minutes":10.62,"words":3185},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/networking/TCP之旅.md"}');export{C as comp,g as data};
