import{_ as a}from"./pointer_move-CZN7IsGE.js";import{_ as s,c as i,f as t,o as n}from"./app-D22ydJtp.js";const p={};function r(l,e){return n(),i("div",null,e[0]||(e[0]=[t('<h1 id="本地线程分配缓冲-tlab" tabindex="-1"><a class="header-anchor" href="#本地线程分配缓冲-tlab"><span>本地线程分配缓冲（TLAB）</span></a></h1><p>Java虚拟机遇到 new 指令时，需要在堆内存上为新对象分配内存空间。如果堆是规整的，一边是分配过的内存，一边是空闲内存，那只要在中间用一个指针隔开，为新对象分配内存时，指针往后移动相应的空间距离即可。</p><p><img src="'+a+'" alt="pointer_move"></p><p>然而，在多线程环境下，线程A和线程B同时为新对象分配内存，线程A还没来得及改指针位置，线程B也使用了这个位置来分配内存，就会出现问题。有两种方法解决这个问题，第一是采用同步，事实上虚拟机采用的 CAS 失败重试的方式来保证更新内存的原子性。第二种是本地线程分配缓冲（Thread Local Allocation Buffer）。</p><p>本地线程分配缓冲会在 Java 堆内存里预先分配一小块内存专门给某个线程用来分配空间，所以不同的线程分配内存是在不同的位置。这样就不会导致冲突。只有当 TLAB 用完并分配新的缓冲区时，才需要同步锁定。</p><p><img src="'+a+`" alt="pointer_move2"></p><p>在 Java 中，用以下参数来设定是否要开启TLAB</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 启用TLAB（默认）</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">XX</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">UseTLAB</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 禁用TLAB</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">XX</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">UseTLAB</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 设置TLAB空间所占用Eden空间的百分比大小(默认1%)</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">XX</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">:</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">TLABWasteTargetPercent</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考：https://blog.csdn.net/zyc88888/article/details/80361635</p><hr><p>持续更新</p>`,11)]))}const d=s(p,[["render",r],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/java/dsqtlej1/","title":"Java虚拟机（五）JVM参数和调优","lang":"zh-CN","frontmatter":{"title":"Java虚拟机（五）JVM参数和调优","comments":true,"categories":["Java","JVM"],"tags":["Java","JVM"],"abbrlink":"a3255dff","createTime":"2018/10/28 16:22:48","permalink":"/java/dsqtlej1/","description":"本地线程分配缓冲（TLAB） Java虚拟机遇到 new 指令时，需要在堆内存上为新对象分配内存空间。如果堆是规整的，一边是分配过的内存，一边是空闲内存，那只要在中间用一个指针隔开，为新对象分配内存时，指针往后移动相应的空间距离即可。 pointer_move 然而，在多线程环境下，线程A和线程B同时为新对象分配内存，线程A还没来得及改指针位置，线程B...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/java/dsqtlej1/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"Java虚拟机（五）JVM参数和调优"}],["meta",{"property":"og:description","content":"本地线程分配缓冲（TLAB） Java虚拟机遇到 new 指令时，需要在堆内存上为新对象分配内存空间。如果堆是规整的，一边是分配过的内存，一边是空闲内存，那只要在中间用一个指针隔开，为新对象分配内存时，指针往后移动相应的空间距离即可。 pointer_move 然而，在多线程环境下，线程A和线程B同时为新对象分配内存，线程A还没来得及改指针位置，线程B..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jerrysheh.com/images/Java/pointer_move.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java虚拟机（五）JVM参数和调优\\",\\"image\\":[\\"https://jerrysheh.com/images/Java/pointer_move.png\\",\\"https://jerrysheh.com/images/Java/pointer_move.png\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":1.34,"words":402},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/java/4.jvm/Java虚拟机（五）参数调优.md"}');export{d as comp,c as data};
