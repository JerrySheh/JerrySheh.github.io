import{_ as t,c as d,f as a,o as s}from"./app-D22ydJtp.js";const i={};function n(r,e){return s(),d("div",null,e[0]||(e[0]=[a(`<p>正则表达式（Regular Expression，在代码中常简写为 regex、regexp 或 RE），又称规则表达式，是计算机科学的一个概念。通常被用来检索、替换那些符合某个模式(规则)的文本。</p><hr><h1 id="正则表达式的基本规则" tabindex="-1"><a class="header-anchor" href="#正则表达式的基本规则"><span>正则表达式的基本规则</span></a></h1><h2 id="单个字符匹配" tabindex="-1"><a class="header-anchor" href="#单个字符匹配"><span>单个字符匹配</span></a></h2><table><thead><tr><th>字符</th><th>规则</th><th>例子</th></tr></thead><tbody><tr><td>|转义字符</td><td><code>\\(</code>表示左括号</td><td></td></tr><tr><td>.</td><td>匹配除了\\n之外的单个字符一次</td><td><code>a.c</code></td></tr><tr><td>\\d</td><td>匹配一个数字，等同<code>[0-9]</code></td><td><code>1\\d8</code>匹配 138</td></tr><tr><td>\\D</td><td>匹配一个非数字</td><td><code>1\\d8</code>匹配 1A8</td></tr><tr><td>\\w</td><td>匹配一个字母、数字或下划线(w的意思是word)</td><td></td></tr><tr><td>\\W</td><td>匹配一个非字母、数字或下划线</td><td></td></tr><tr><td>\\s</td><td>匹配任何空白字符（空格、制表符、换页符等）</td><td></td></tr><tr><td>\\S</td><td>匹配任何非空白字符</td><td></td></tr><tr><td>x | y</td><td>匹配x或者y（表达式）</td><td></td></tr><tr><td>^</td><td>匹配行首</td><td><code>^www</code>匹配以www开头</td></tr><tr><td>$</td><td>匹配行尾</td><td><code>$com</code>匹配以com结尾</td></tr><tr><td>[^A-F]</td><td>取反</td><td><code>[^A-F]</code>匹配A-F之外的字符</td></tr></tbody></table><h2 id="多个字符匹配" tabindex="-1"><a class="header-anchor" href="#多个字符匹配"><span>多个字符匹配</span></a></h2><table><thead><tr><th>字符</th><th>规则</th><th>例子</th></tr></thead><tbody><tr><td>[xyz]</td><td>匹配包含的任意一字符</td><td><code>a[xyz]b</code>，匹配 axb，ayb, azb</td></tr><tr><td>[a-z]</td><td>匹配指定范围内的任意字符</td><td><code>[0-9]</code></td></tr></tbody></table><ul><li>| 匹配前面的子表达式零次或多次| <code>zo*</code>，匹配z，zo，zoo</li></ul><ul><li>| 匹配前面的子表达式一次或多次| <code>zo+</code>，匹配zo，zoo ? | 匹配前面的子表达式零次或一次| <code>do(es)?</code>，匹配do，does {n,m}|最少匹配n次，最多匹配m次|<code>(o{1,3})</code>，匹配foooood中的3个o {n}|匹配确定的n次|<code>o{2}</code>，匹配food中的oo，不匹配fod中的o</li></ul><h2 id="分组匹配" tabindex="-1"><a class="header-anchor" href="#分组匹配"><span>分组匹配</span></a></h2><p>可以用括号把要匹配的内容分组，例如匹配带区号的电话号码，可以把区号和电话分组。这样更容易看。</p><table><thead><tr><th>字符</th><th>规则</th><th>例子</th></tr></thead><tbody><tr><td>()</td><td>分组</td><td><code>(\\d{3,4})\\-(\\d{6,8})</code></td></tr><tr><td>(|)</td><td>分组和或的组合</td><td>hello\\s(world|ketty|jerry)</td></tr></tbody></table><p>分组还有一个好处，当你想使用正则替换时，可以用 <code>$1</code>、<code>$2</code> 来表示第几组的内容。例如，在 Java 中为匹配到的内容前后分别加 <code>&lt;b&gt; &lt;/b&gt;</code> :</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">s</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">replaceAll</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\\\</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">s([a-z]{4})</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\\\</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">s</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> &lt;b&gt;$1&lt;/b&gt; </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="非贪婪匹配" tabindex="-1"><a class="header-anchor" href="#非贪婪匹配"><span>非贪婪匹配</span></a></h2><p>假设要求 1230000 后面有几个零，正则为 <code>(\\d+)(0*)</code>，但是却发现第一组匹配到 1230000，第二组匹配到空白。我们期望的是第一组匹配到 123，第二组匹配到 0000。</p><p>此时可以在第一组末尾加 <code>?</code> 表示非贪婪匹配，如：<code>(\\d+?)(0*)</code>，这样第一组就会少匹配，第二组多匹配。</p><p>而对于 <code>(\\d??)(9*)</code>， 匹配 9999 时，第一组匹配到空白，第二组匹配到 9999。因为第一个问号表示零次或一次，第二个问号表示非贪婪，正则表达式会按最少的零次来匹配。</p><h2 id="匹配中文" tabindex="-1"><a class="header-anchor" href="#匹配中文"><span>匹配中文</span></a></h2><p>匹配非ASCII字符，例如中文，用<code>\\u####</code>的十六进制表示，例如：<code>a\\u548cc</code>匹配字符串<code>a和c</code>，中文字符<code>和</code>的Unicode编码是548c。</p><hr><h1 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h1><h2 id="零宽断言" tabindex="-1"><a class="header-anchor" href="#零宽断言"><span>零宽断言</span></a></h2><p>零宽断言，指定的内容的前面或后面会出现满足指定规则的内容，而自己不占匹配位置。例如 <code>123abc</code> ，我想匹配 <code>123</code> 后面的内容<code>abc</code>，而不包括 <code>123</code> 本身。</p><table><thead><tr><th>字符</th><th>规则</th><th>例子</th></tr></thead><tbody><tr><td>（?=pattern）</td><td>匹配 pattern 前面的内容</td><td><code>\\d(?=\\sword)</code>， 从 <code>1 word</code> 中匹配到 <code>1</code></td></tr><tr><td>（?&lt;=pattern）</td><td>匹配 pattern 后面的内容</td><td><code>(?&lt;=num:)\\d</code>， 从 <code>num:5</code> 中匹配到 <code>5</code></td></tr><tr><td>(?!pattern)</td><td>匹配非 pattern 前面的内容</td><td><code>i(?!k)</code> ，从 <code>wikipedia</code> 中匹配到不是<code>k</code>前面的<code>i</code>，即 wik<strong>i</strong>ped<strong>i</strong>a</td></tr><tr><td>(?&lt;!pattern)</td><td>匹配非 pattern 后面的内容</td><td><code>(?&lt;!k)i</code> ，从 <code>wikipedia</code> 中匹配到不是<code>k</code>后面的<code>i</code>，即w<strong>i</strong>kiped<strong>i</strong>a</td></tr></tbody></table><hr><h1 id="一些实例" tabindex="-1"><a class="header-anchor" href="#一些实例"><span>一些实例</span></a></h1><h2 id="_1-匹配以-str-开头-r-结尾-中间任意个任意字符" tabindex="-1"><a class="header-anchor" href="#_1-匹配以-str-开头-r-结尾-中间任意个任意字符"><span>1.匹配以 Str 开头， r 结尾， 中间任意个任意字符</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Str.*r</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>匹配到 Stringbuffer， StringBuilder</p><h2 id="_2-匹配所有以-结尾-修改成-comment" tabindex="-1"><a class="header-anchor" href="#_2-匹配所有以-结尾-修改成-comment"><span>2. 匹配所有以 , 结尾，修改成 comment &#39;&#39;,</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>查找：</span></span>
<span class="line"><span>(.*),</span></span>
<span class="line"><span></span></span>
<span class="line"><span>替换：</span></span>
<span class="line"><span>$1 comment &#39;&#39;,</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>.表示任意字符，* 表示任意多个，括号用于在下面 $1 保留原内容</p><p>效果：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>原：</span></span>
<span class="line"><span>not null,</span></span>
<span class="line"><span>NUMBER(20),</span></span>
<span class="line"><span></span></span>
<span class="line"><span>现：</span></span>
<span class="line"><span>not null comment &#39;&#39;,</span></span>
<span class="line"><span>NUMBER(20) comment &#39;&#39;,</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-匹配所有以-debug-开头-或-yet-结尾-并且最后有换行符的-由于换行符在-windows-为-crlf-在-linux-为-lf-所以我们匹配1或2次-第一次-s-匹配-cr-第二次匹配-lf-。" tabindex="-1"><a class="header-anchor" href="#_3-匹配所有以-debug-开头-或-yet-结尾-并且最后有换行符的-由于换行符在-windows-为-crlf-在-linux-为-lf-所以我们匹配1或2次-第一次-s-匹配-cr-第二次匹配-lf-。"><span>3. 匹配所有以 [DEBUG] 开头，]] 或 yet 结尾，并且最后有换行符的，由于换行符在 Windows 为 CRLF ，在 Linux 为 LF，所以我们匹配1或2次，第一次 <code>\\s</code> 匹配 CR，第二次匹配 LF 。</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>\\[DEBUG\\].*(\\]\\]|yet)(\\s{1,2})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>tips：用 <code>\\</code> 来转义特殊符号，如匹配 <code>[</code> ，要输入 <code>\\[</code></p><h2 id="_4-匹配16进制数" tabindex="-1"><a class="header-anchor" href="#_4-匹配16进制数"><span>4. 匹配16进制数</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[0-9a-fA-F]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_5-linux中使用-grep-和正则表达式-查找文件" tabindex="-1"><a class="header-anchor" href="#_5-linux中使用-grep-和正则表达式-查找文件"><span>5. Linux中使用 grep 和正则表达式，查找文件</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>grep -E --color &#39;[xyz]&#39; filename</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h1 id="一些有用的网站" tabindex="-1"><a class="header-anchor" href="#一些有用的网站"><span>一些有用的网站</span></a></h1><ul><li><a href="https://regexper.com/" target="_blank" rel="noopener noreferrer">正则可视化</a></li><li><a href="https://regexr.com/" target="_blank" rel="noopener noreferrer">正则验证和可视化</a></li></ul><hr><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945288020320" target="_blank" rel="noopener noreferrer">廖雪峰教程</a></li><li><a href="https://www.zhihu.com/question/48219401" target="_blank" rel="noopener noreferrer">知乎：你是如何学会正则表达式的？</a></li></ul>`,48)]))}const o=t(i,[["render",n],["__file","index.html.vue"]]),c=JSON.parse(`{"path":"/regular/","title":"给自己的正则表达式备忘","lang":"zh-CN","frontmatter":{"title":"给自己的正则表达式备忘","categories":["技能","正则表达式"],"tags":["linux"],"abbrlink":"e36ce161","createTime":"2017/10/31 08:53:39","permalink":"/regular/","description":"正则表达式（Regular Expression，在代码中常简写为 regex、regexp 或 RE），又称规则表达式，是计算机科学的一个概念。通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的基本规则 单个字符匹配 多个字符匹配 | 匹配前面的子表达式零次或多次| zo*，匹配z，zo，zoo | 匹配前面的子表达式一次或多次| z...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/regular/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"给自己的正则表达式备忘"}],["meta",{"property":"og:description","content":"正则表达式（Regular Expression，在代码中常简写为 regex、regexp 或 RE），又称规则表达式，是计算机科学的一个概念。通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式的基本规则 单个字符匹配 多个字符匹配 | 匹配前面的子表达式零次或多次| zo*，匹配z，zo，zoo | 匹配前面的子表达式一次或多次| z..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"给自己的正则表达式备忘\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"单个字符匹配","slug":"单个字符匹配","link":"#单个字符匹配","children":[]},{"level":2,"title":"多个字符匹配","slug":"多个字符匹配","link":"#多个字符匹配","children":[]},{"level":2,"title":"分组匹配","slug":"分组匹配","link":"#分组匹配","children":[]},{"level":2,"title":"非贪婪匹配","slug":"非贪婪匹配","link":"#非贪婪匹配","children":[]},{"level":2,"title":"匹配中文","slug":"匹配中文","link":"#匹配中文","children":[]},{"level":2,"title":"零宽断言","slug":"零宽断言","link":"#零宽断言","children":[]},{"level":2,"title":"1.匹配以 Str 开头， r 结尾， 中间任意个任意字符","slug":"_1-匹配以-str-开头-r-结尾-中间任意个任意字符","link":"#_1-匹配以-str-开头-r-结尾-中间任意个任意字符","children":[]},{"level":2,"title":"2. 匹配所有以 , 结尾，修改成 comment '',","slug":"_2-匹配所有以-结尾-修改成-comment","link":"#_2-匹配所有以-结尾-修改成-comment","children":[]},{"level":2,"title":"3. 匹配所有以 [DEBUG] 开头，]] 或 yet 结尾，并且最后有换行符的，由于换行符在 Windows 为 CRLF ，在 Linux 为 LF，所以我们匹配1或2次，第一次 \\\\s 匹配 CR，第二次匹配 LF 。","slug":"_3-匹配所有以-debug-开头-或-yet-结尾-并且最后有换行符的-由于换行符在-windows-为-crlf-在-linux-为-lf-所以我们匹配1或2次-第一次-s-匹配-cr-第二次匹配-lf-。","link":"#_3-匹配所有以-debug-开头-或-yet-结尾-并且最后有换行符的-由于换行符在-windows-为-crlf-在-linux-为-lf-所以我们匹配1或2次-第一次-s-匹配-cr-第二次匹配-lf-。","children":[]},{"level":2,"title":"4. 匹配16进制数","slug":"_4-匹配16进制数","link":"#_4-匹配16进制数","children":[]},{"level":2,"title":"5. Linux中使用 grep 和正则表达式，查找文件","slug":"_5-linux中使用-grep-和正则表达式-查找文件","link":"#_5-linux中使用-grep-和正则表达式-查找文件","children":[]}],"readingTime":{"minutes":3.97,"words":1192},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/regular/给自己的正则表达式备忘.md","categoryList":[{"id":"4358b5","sort":10002,"name":"notes"},{"id":"74f32c","sort":10003,"name":"regular"}]}`);export{o as comp,c as data};
