import{_ as i,c as a,f as e,o as n}from"./app-D22ydJtp.js";const t={};function l(h,s){return n(),a("div",null,s[0]||(s[0]=[e(`<p>如果你想获得更高的性能，使用并发是不可避免的。但是并发编程要比单线程编程难得多，一方面它很容易出错，另一方面错误很难复现。这一篇主要介绍如何写出正确、简洁、可靠的并发程序。</p><h1 id="item-78-同步访问可共享的互斥数据" tabindex="-1"><a class="header-anchor" href="#item-78-同步访问可共享的互斥数据"><span>Item 78 同步访问可共享的互斥数据</span></a></h1><p>有些人认为 <code>synchronized</code> 关键字只是用于互斥场景，其实这是片面的，这个关键字还能保证一个线程的修改对另一个线程可见。</p><p>比如你想在后台启动一个任务，并且主线程随时停止它：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> StopThread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> stop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> throws</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> InterruptedException</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Thread</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> background</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> -&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">            int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">            while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">stop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">                i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        });</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        backgroud</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">start</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        TimeUnit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SECONDS</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        stop </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个程序可能永远都停不下来，因为虚拟机可能会对这段代码做编译器优化，将</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">stop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>优化为</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">stop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决办法有两种，第一种是对 <code>stop</code> 变量的的读写封装成方法，并加上 <code>synchronized</code> 关键字。通过方法来同步访问。另一种方法则是直接对 <code>stop</code> 变量加 <code>volatile</code> 关键字，这个关键字保证了一个线程对变量的修改对另一个线程立即可见。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> StopThread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> volatile</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> boolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> stop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是请注意， <code>volatile</code> 并不能保证非原子操作的同步性。如 i++ （同时被两个线程访问修改， 仅仅用 <code>volatile</code> 是不够的。即 <code>volatile</code> 是解决可见性问题的，不是解决非原子操作同步性问题的。</p><blockquote><p>i++ 不是一个原子操作，它分为三步：第一，从内存取值放入寄存器，第二，执行加一，第三，放回内存。</p></blockquote><p>解决 i++ 的问题，除了可以用 <code>synchronized</code> 之外，还可以将 i 封装成 <code>AtomicInteger</code> 这种原子类， 确保自增是原子的，就不会出问题。</p><hr><h1 id="item-79-不要过度同步" tabindex="-1"><a class="header-anchor" href="#item-79-不要过度同步"><span>Item 79 不要过度同步</span></a></h1><p>遍历一个列表时，如果对这个列表做了修改，那么会抛出一个 <code>ConcurrentModificationException</code>。那么加入我们对迭代方法加同步块呢？同步块可以防止并发的修改，但是无法防止迭代线程本身回调自己进行修改，因为同步块是可重入的，所以在这个场景下是没有意义的。那么我们在迭代过程启动一个后台线程来修改呢？很遗憾，虽然主线程一直在等待后台线程来修改，主线程已经有锁了，后台线程却因为锁永远修改不到，导致死锁。</p><p>这给我们的一个启示是：<strong>应该在同步区域内做尽可能少的工作，不要从同步区域中调用外来方法（这种做法在真实的系统中已经造成了许多死锁）</strong>。</p><p>解决这一问题的途径是使用 <code>CopyOnWriteArrayList</code>，这是一种写时复制的技术。它通过重新拷贝整个底层数组，在这里实现所有的写操作，写完之后，再将修改完的副本替换成原来的数据，这样就可以保证写操作不会影响读操作了。由于内部数组永远不改动，因此迭代不需要锁定，速度也非常快。<strong>适合少写多读的场景</strong>。</p><hr><h1 id="item-80-executor、task-和-stream-优先于线程" tabindex="-1"><a class="header-anchor" href="#item-80-executor、task-和-stream-优先于线程"><span>Item 80 executor、task 和 stream 优先于线程</span></a></h1><p>Java 的 <code>Executors</code> 框架提供了强大的线程池支持，只需要一行代码，即可以创建合适的任务执行器（单线程任务、多线程任务、固定线程数任务等）。当这些内置的执行器不适用你的场景时，才考虑使用 <code>ThreadPoolExecutor</code> 本身来构造你自己的线程池。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 创建一个单线程任务</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ExecutorService</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> exec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newSingleThreadExecutor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 缓存线程池（不适合大负载的服务器，因为当任务过多，线程池没有足够的空闲线程，会无限的增加线程数，有一定风险）</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ExecutorService</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> exec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newCachedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 固定个数线程池</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ExecutorService</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> exec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Executors</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">newFixedThreadPool</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 启动/关闭线程池</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">exec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">execute</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">runnable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">exec</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">shutdown</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 7 中，<code>Executor</code> 框架还支持 fork-join 任务，在 Java 8 中，Parallel streams （Item 48）是在 fork join 池上编写的，我们不费什么力气就能享受到它们的性能优势，前提是它们正好适用于我们手边的任务。</p><p>作者忠告：不仅应该尽量不要编写自己的工作队列，而且还应该尽量不直接使用线程。</p><hr><h1 id="item-81-并发工具优于-wait-和-notify" tabindex="-1"><a class="header-anchor" href="#item-81-并发工具优于-wait-和-notify"><span>Item 81 并发工具优于 wait 和 notify</span></a></h1><p><code>java.util.concurrent</code> 包含三类有用的工具，分别是 Executor Framework 、并发集合（ConcurrentCollection）以及同步器（Synchronizer）。</p><p>并发集合包含 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>BlockingQueue</code> 等，同步器包含 <code>CountDownLatch</code>、 <code>Semaphore</code> 和 <code>CyclicBarrier</code> 等。</p><p>没有理由在新代码中使用 wait 方法和 notify 方法。如果你不得不维护老旧代码继续使用 wait 和 notify，那么遵守一个原则：始终应该使用 wait 循环模式来调用 wait 方法；永远不要在循环之外调用 wait 方法。一般情况下，应该优先使用 notifyAll 方法，而不是使用 notify 方法。</p><hr><h1 id="item-82-文档应包含线程安全属性" tabindex="-1"><a class="header-anchor" href="#item-82-文档应包含线程安全属性"><span>Item 82 文档应包含线程安全属性</span></a></h1><p>当你编写了一个类，在文档中应该尽可能包含其线程安全属性，常见的安全属性有以下几类：</p><ul><li><strong>不可变对象</strong>： 这个类的实例看起来是常量，不需要外部同步，如 <code>String</code>、<code>Long</code> 和 <code>BigInteger</code>。</li><li><strong>无条件线程安全</strong>： 该类的实例是可变的，但是该类具有足够的内部同步，因此无需任何外部同步即可并发地使用该类的实例。如 <code>AtomicLong</code> 和 <code>ConcurrentHashMap</code>。</li><li><strong>有条件的线程安全</strong>: 与无条件线程安全类似，只是有些方法需要外部同步才能安全并发使用。如 Collections.synchronized 包装器返回的集合，其迭代器需要外部同步。</li><li><strong>非线程安全</strong>： 该类的实例是可变的。要并发地使用它们，客户端必须使用外部同步来包围每个方法调用（或调用序列），如大部分通用的集合实现， <code>ArrayList</code> 和 <code>HashMap</code> 等。 -- <strong>线程对立</strong>： 即使每个方法调用都被外部同步包围，该类对于并发使用也是不安全的。线程对立通常是由于在不同步的情况下修改静态数据而导致的。没有人故意编写线程对立类；此类通常是由于没有考虑并发性而导致。当发现类或方法与线程不相容时，通常将其修复或弃用。</li></ul><p>此外，当我们使用显式私有锁时，Lock 字段应该始终声明为 final，以防无意中地改变它。但是，私有锁对象用法只能在无条件的线程安全类上使用。有条件的线程安全类不能使用这种用法。</p>`,35)]))}const k=i(t,[["render",l],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/java/mmbn7p25/","title":"Effective Java（十）并发","lang":"zh-CN","frontmatter":{"title":"Effective Java（十）并发","categories":["Java","Effective Java"],"tags":["Java"],"abbrlink":"15ac17ad","createTime":"2021/11/07 21:57:01","permalink":"/java/mmbn7p25/","description":"如果你想获得更高的性能，使用并发是不可避免的。但是并发编程要比单线程编程难得多，一方面它很容易出错，另一方面错误很难复现。这一篇主要介绍如何写出正确、简洁、可靠的并发程序。 Item 78 同步访问可共享的互斥数据 有些人认为 synchronized 关键字只是用于互斥场景，其实这是片面的，这个关键字还能保证一个线程的修改对另一个线程可见。 比如你想...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/java/mmbn7p25/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"Effective Java（十）并发"}],["meta",{"property":"og:description","content":"如果你想获得更高的性能，使用并发是不可避免的。但是并发编程要比单线程编程难得多，一方面它很容易出错，另一方面错误很难复现。这一篇主要介绍如何写出正确、简洁、可靠的并发程序。 Item 78 同步访问可共享的互斥数据 有些人认为 synchronized 关键字只是用于互斥场景，其实这是片面的，这个关键字还能保证一个线程的修改对另一个线程可见。 比如你想..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Effective Java（十）并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":5.82,"words":1747},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/java/2.effective java/10.Effective-Java（十）并发.md"}');export{k as comp,d as data};
