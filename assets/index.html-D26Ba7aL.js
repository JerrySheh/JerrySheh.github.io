import{_ as t,c as r,f as n,o as a}from"./app-D22ydJtp.js";const s="/images/OS/page.png",l="/images/OS/reqpage.png",i={};function p(o,e){return a(),r("div",null,e[0]||(e[0]=[n('<p>计算机系统存储层次大致可以分为：</p><p>寄存器 -&gt; 高速缓存 -&gt; <strong>主存储器</strong> -&gt; 磁盘缓存 -&gt; 固定磁盘 -&gt; 可移动存储介质</p><p>由于存储器还是一种稀缺资源，操作系统对存储器的管理主要是对主存储器（主存、或者通俗地称内存）的管理。</p><hr><h1 id="程序的装入和链接" tabindex="-1"><a class="header-anchor" href="#程序的装入和链接"><span>程序的装入和链接</span></a></h1><p>用户程序在执行前，必须先装入内存，然后才变成一个进程。</p><p>这个过程分为以下几步:</p><ul><li><strong>编译</strong>：由编译器（Compiler）对源码进行编译，形成目标模块（Object Module）</li><li><strong>链接</strong>：由链接器（Linker）将 Object Modules 与所需的库函数链接在一起，形成装入模块（Load Module）。包括静态链接和装入时动态链接。</li><li><strong>装入</strong>：由装入器（Loader）将模块装入内存</li></ul><h2 id="程序的装入" tabindex="-1"><a class="header-anchor" href="#程序的装入"><span>程序的装入</span></a></h2><p>三种装入方式：</p><ul><li><strong>绝对装入方式</strong>：只适用于单道程序环境，使用的是绝对地址（地址值可由编译器生成或程序员指定）</li><li><strong>可重定位装入方式</strong>：重定位在装入时一次性完成，故也称静态重定位。其程序地址空间也就是逻辑地址空间。</li><li><strong>动态运行时的装入方式</strong>：其物理地址是在程序运行时才确定的。</li></ul><h2 id="程序的链接" tabindex="-1"><a class="header-anchor" href="#程序的链接"><span>程序的链接</span></a></h2><p>三种链接方式：</p><ul><li><strong>静态链接方式</strong></li><li><strong>装入时动态链接</strong></li><li><strong>运行时动态链接</strong></li></ul><hr><h1 id="动态分区分配算法" tabindex="-1"><a class="header-anchor" href="#动态分区分配算法"><span>动态分区分配算法</span></a></h1><p>根据实际需要，动态地为程序分配内存空间。包括以下算法：</p><ul><li><strong>首次适应（First Fit）</strong>：在分配内存时，从链首开始顺序查找，直到找到一个大小能满足要求的空闲分区。这种算法优先利用低址部分的空闲分区，保留高址部分的大空闲区。</li><li><strong>最佳适应（Best Fit）</strong>：先将所有的空闲分区按容量从小到大排序，然后再找到满足要求的空闲区。这样就能做到把既满足空间大小要求、又是最小的空闲分区分配给作业。</li></ul><hr><h1 id="交换技术-swapping" tabindex="-1"><a class="header-anchor" href="#交换技术-swapping"><span>交换技术（Swapping）</span></a></h1><p>存储管理中采用覆盖与交换（swap）技术是为了<strong>减少程序占用主存空间</strong>。将内存中暂时不会被调用的进程交换到外存上。这有效提高了内存利用率，减少程序所占的主存空间。</p><blockquote><p>Swapping是在逻辑上扩充主存，并不能从物理上扩充主存容量。</p></blockquote><p>Swap中的虚拟内存的容量由内存和外存容量之和决定，取决于逻辑地址位数。</p><hr><h1 id="离散分配" tabindex="-1"><a class="header-anchor" href="#离散分配"><span>离散分配</span></a></h1><p>如果允许将一个进程 <strong>分散地</strong> 装入到许多不相邻的分区中，就可以充分地利用内存空间。</p><h2 id="分页存储管理方式" tabindex="-1"><a class="header-anchor" href="#分页存储管理方式"><span>分页存储管理方式</span></a></h2><p>分页存储把进程的逻辑地址空间分为若干个页，称为页面，比如第0页、第1页、第2页，每一个都有固定的大小，称为页面大小（通常是2的幂）。</p><p>其地址结构如下：</p><p><img src="'+s+'" alt=""></p><p>如上图，是一个 32 位的地址结构。其中，第 0 - 11 位叫做 位（偏）移量（也就是页内地址），第 12 - 31 位 是页号，也就是第几页的二进制表示。</p><p>于是，给定一个逻辑地址空间A，页面大小为L</p><ul><li>页号 P 为：P = [INT] A / L</li><li>页内地址 d 为： [A] MOD L</li></ul><h2 id="分段存储管理方式" tabindex="-1"><a class="header-anchor" href="#分段存储管理方式"><span>分段存储管理方式</span></a></h2><p>为了满足用户（程序员）在编程和使用上多方面的要求，引入分段存储管理方式。</p><p>这种方式把作业的地址空间划分为若干个段、每个段定义了一组逻辑信息。例如主程序段MAIN、自程序段X、数据段D、栈段S等。</p><p>系统为每一个段分配一个连续的分区，一个程序中的各个段，可以载入到内存中不同的分区中。通过段表来实现逻辑段到物理内存的映射。</p><p>有以下公式：</p><p>偏移量 = 逻辑地址 % 页面大小</p><p>物理地址 = 块号 × 页面大小 + 偏移量</p><h2 id="段页式存储管理方式" tabindex="-1"><a class="header-anchor" href="#段页式存储管理方式"><span>段页式存储管理方式</span></a></h2><p>将分页和分段结合起来，既能减少存储碎片，又能方便实现数据和程序的共享。</p><hr><h1 id="虚拟存储器" tabindex="-1"><a class="header-anchor" href="#虚拟存储器"><span>虚拟存储器</span></a></h1><p>GTA 5这款游戏，解压完以后有大约 65 GB，运行这个游戏，很少有人拥有 65 GB 以上的内存。这时候就要用到虚拟存储器。虚拟存储器是一种从逻辑上实现对内存容量扩充的技术。</p><p>传统的存储器管理方式，有两个特征：一次性 和 驻留性。也就是作业必须一次性装入内存，然后才开始运行，装入内存后，执行过的片段依然会驻留在内存里，浪费内存空间。</p><p>我们可以利用程序运行的 <strong>局部性原理</strong>，也就是说，程序运行过程中，在一较短时间内通常只访问某个部分的内存。于是，我们没有必要将应用程序一次性全部装入内存，而仅须将当前要运行的少数页面或段先装入内存，其余部分暂留在硬盘上。然后通过一些算法在内存和外存中置换。</p><h2 id="虚拟存储器定义" tabindex="-1"><a class="header-anchor" href="#虚拟存储器定义"><span>虚拟存储器定义</span></a></h2><p>所谓虚拟存储器，指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其三个特征为：<strong>多次行</strong>、<strong>对换性</strong>、<strong>虚拟性</strong>。</p><p>换进和换出能有效地提高内存利用率。</p><h2 id="虚拟存储器实现" tabindex="-1"><a class="header-anchor" href="#虚拟存储器实现"><span>虚拟存储器实现</span></a></h2><p>在分页系统的基础上，增加调页功能和页面置换功能。允许用户程序只装入少数页面的程序（及数据）即可启动运行，然后通过<strong>调页功能</strong>和<strong>页面置换</strong>功能陆续地把即将运行的页面调入内存。</p><h2 id="硬件支持" tabindex="-1"><a class="header-anchor" href="#硬件支持"><span>硬件支持</span></a></h2><p>首先 <strong>请求页表</strong> 将用户空间的逻辑地址映射为内存空间中的物理地址。请求页表如下：</p><p><img src="'+l+'" alt=""></p><ul><li>状态位P：指示该页是否已调入内存</li><li>访问字段A：记录本页在一段时间内被访问的次数（供给置换算法换进换出时参考）</li><li>修改位M：标识该页换进内存后是否被修改过（供置换页面时参考）</li><li>外存地址：指出该页在外存上的地址</li></ul><p>此外，还要有一个<strong>缺页中断机构</strong>，不同于普通中断，表现在：</p><ul><li>普通中断在一条指令执行结束后，才检查是否有中断请求。缺页中断是在指令执行期间，若发现缺页，便立即产生和处理缺页中断信号，及时把所需的页调入内存。</li><li>系统中的硬件机构应能保存多次中断时的状态。</li></ul><h2 id="置换算法" tabindex="-1"><a class="header-anchor" href="#置换算法"><span>置换算法</span></a></h2><p>基本：</p><ul><li><strong>最佳（Optimal）页面置换算法</strong>：把以后不使用的，或者是在最长（未来）时间内不再被访问的页面，置换出去。该算法是无法实现的，因为无法预知未来哪个页面不再被访问。但可以作为其他算法性能的参考。</li><li><strong>先进先出（FIFO）页面置换算法</strong>：顾名思义，最先进入的最先被置换出去。</li><li><strong>最近最久未使用（LRU，Least Recently Used）置换算法</strong>：选择最近最久未使用的页面予以淘汰。</li></ul><p>改进：</p><ul><li><strong>Clock置换算法</strong>：添加一个访问位，当某页被访问时，将访问位置1。然后将所有页面通过指针链接成循环队列。在选择置换的时候，判断访问位，如果是0，将该页换出，如果是1，将其置0，给予该页第二次驻留内存的机会。指针往后移动。</li><li><strong>改进型Clock置换算法</strong>：在上面的基础上，增加一个修改位。优先淘汰访问位为0且未被修改的页面。</li></ul>',63)]))}const g=t(i,[["render",p],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/computer-system/wxsehf2y/","title":"操作系统漫游（四）存储器管理","lang":"zh-CN","frontmatter":{"title":"操作系统漫游（四）存储器管理","comments":true,"categories":"操作系统","tags":["操作系统"],"abbrlink":"260127af","createTime":"2018/05/07 12:46:04","permalink":"/computer-system/wxsehf2y/","description":"计算机系统存储层次大致可以分为： 寄存器 -> 高速缓存 -> 主存储器 -> 磁盘缓存 -> 固定磁盘 -> 可移动存储介质 由于存储器还是一种稀缺资源，操作系统对存储器的管理主要是对主存储器（主存、或者通俗地称内存）的管理。 程序的装入和链接 用户程序在执行前，必须先装入内存，然后才变成一个进程。 这个过程分为以下几步: 编译：由编译器（Compi...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/computer-system/wxsehf2y/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"操作系统漫游（四）存储器管理"}],["meta",{"property":"og:description","content":"计算机系统存储层次大致可以分为： 寄存器 -> 高速缓存 -> 主存储器 -> 磁盘缓存 -> 固定磁盘 -> 可移动存储介质 由于存储器还是一种稀缺资源，操作系统对存储器的管理主要是对主存储器（主存、或者通俗地称内存）的管理。 程序的装入和链接 用户程序在执行前，必须先装入内存，然后才变成一个进程。 这个过程分为以下几步: 编译：由编译器（Compi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://jerrysheh.com/images/OS/page.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"操作系统"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"操作系统漫游（四）存储器管理\\",\\"image\\":[\\"https://jerrysheh.com/images/OS/page.png\\",\\"https://jerrysheh.com/images/OS/reqpage.png\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"程序的装入","slug":"程序的装入","link":"#程序的装入","children":[]},{"level":2,"title":"程序的链接","slug":"程序的链接","link":"#程序的链接","children":[]},{"level":2,"title":"分页存储管理方式","slug":"分页存储管理方式","link":"#分页存储管理方式","children":[]},{"level":2,"title":"分段存储管理方式","slug":"分段存储管理方式","link":"#分段存储管理方式","children":[]},{"level":2,"title":"段页式存储管理方式","slug":"段页式存储管理方式","link":"#段页式存储管理方式","children":[]},{"level":2,"title":"虚拟存储器定义","slug":"虚拟存储器定义","link":"#虚拟存储器定义","children":[]},{"level":2,"title":"虚拟存储器实现","slug":"虚拟存储器实现","link":"#虚拟存储器实现","children":[]},{"level":2,"title":"硬件支持","slug":"硬件支持","link":"#硬件支持","children":[]},{"level":2,"title":"置换算法","slug":"置换算法","link":"#置换算法","children":[]}],"readingTime":{"minutes":6.85,"words":2054},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/computer-system/6.操作系统漫游（四）存储器管理.md"}');export{g as comp,c as data};
