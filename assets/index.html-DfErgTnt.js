import{_ as a,c as e,f as i,o as n}from"./app-D22ydJtp.js";const t={};function p(l,s){return n(),e("div",null,s[0]||(s[0]=[i(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>一个 web 应用是如何运行的？作为软件开发者，我们必须得有一个完整的层次化的认知。这一篇将从浏览器，到 HTTP，HTML，web server，request handles 等方面切入，聊聊当我们输入一个网址的时候，后台到底发生了什么。</p><ul><li>本文转载自：<a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html" target="_blank" rel="noopener noreferrer">韩星的博客</a>，对翻译进行了调整。</li><li>英文原文：<a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/" target="_blank" rel="noopener noreferrer">what-really-happens-when-you-navigate-to-a-url</a></li></ul><h2 id="_1-输入网址" tabindex="-1"><a class="header-anchor" href="#_1-输入网址"><span>1. 输入网址</span></a></h2><p>一切从你在浏览器输入一个网址开始</p><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image4.png" alt="输入网址"></p><h2 id="_2-dns查找" tabindex="-1"><a class="header-anchor" href="#_2-dns查找"><span>2. DNS查找</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image13.png" alt="查找ip"></p><p>浏览器所做的第一步是通过访问的域名找出对应的IP地址。这一步叫DNS查找。</p><h3 id="dns查找过程" tabindex="-1"><a class="header-anchor" href="#dns查找过程"><span>DNS查找过程</span></a></h3><ul><li><strong>浏览器缓存</strong>：浏览器会缓存DNS记录一段时间。操作系统没有规定浏览器要存储DNS记录多长时间，所以不同浏览器储存各自的缓存时长也不尽相同（一般2分钟到30分钟不等）。</li><li><strong>系统缓存</strong>：如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname）。这样便可获得操作系统中的DNS缓存。</li><li><strong>路由器缓存</strong>：如果系统缓存也没有，查询请求会继续发向路由器，路由器一般会有自己的DNS缓存。</li><li><strong>ISP缓存</strong>：接下来要查找的就是ISP缓存DNS的服务器。在这里一般都能找到相应的缓存记录。</li><li><strong>递归搜索</strong>：你的ISP的DNS服务器从根域名服务器开始进行递归搜索，从.com顶级域名服务器到Facebook的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。</li></ul><blockquote><p><code>ISP，因特网服务提供商（Internet Service Provider）</code>ISP有很多，比如住宅区ISP，公司ISP，大学ISP，这些低层的ISP，通过区域的ISP（比如市级、省级ISP）互联，区域ISP又由国家或国际的高层ISP互联起来。形成了一个网络的网络。</p></blockquote><p>DNS递归查找如下图所示：</p><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/500pxAn_example_of_theoretical_DNS_recursion_svg.png" alt="500px-An_example_of_theoretical_DNS_recursion_svg"></p><h3 id="解决多个ip对应一个域名的问题" tabindex="-1"><a class="header-anchor" href="#解决多个ip对应一个域名的问题"><span>解决多个ip对应一个域名的问题</span></a></h3><p>像 wikipedia.org 或者 facebook.com 这样的域名，看上去好像只能对应一个单独的IP地址。但往往一个域名可能要对应好几个ip地址，有几种解决办法：</p><ul><li><strong>循环 DNS (Round-robin DNS)</strong>： DNS 查找时返回多个IP的解决方案。举例来说，Facebook.com实际上对应了四个IP地址。</li><li><strong>负载均衡 (Load-balancer)</strong>：是一个能够监听特定IP地址并将网络请求转发到其他服务器上的硬件设备。 一些大型的站点一般都会使用这种昂贵的高性能负载均衡器。</li><li><strong>地理 DNS(Geographic DNS)</strong>：根据用户所处的地理位置，通过把域名映射到多个不同的IP地址提高可扩展性。这样不同的服务器不能够更新同步状态，但映射静态内容的话非常好。</li><li><strong>Anycast</strong>：是一个将IP地址映射多个物理服务器上的路由技术。 美中不足的是，Anycast与TCP协议并不是很兼容，所以很少应用在一些方案中。大多数DNS服务器使用Anycast来获得高效低延迟的DNS查找。</li></ul><h2 id="_3-发送http请求" tabindex="-1"><a class="header-anchor" href="#_3-发送http请求"><span>3.发送HTTP请求</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image22.png" alt="GET"></p><p>像Facebook主页这样的动态页面，打开后浏览器缓存很快甚至马上就会过期。毫无疑问动态页面不能从浏览器缓存中读取。</p><p>所以，浏览器把以下请求发送到Facebook所在的服务器：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>GET http://facebook.com/ HTTP/1.1</span></span>
<span class="line"><span> Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]</span></span>
<span class="line"><span> User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]</span></span>
<span class="line"><span> Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span> Connection: Keep-Alive</span></span>
<span class="line"><span> Host: facebook.com</span></span>
<span class="line"><span> Cookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>GET 这个请求定义了要读取的URL： “ http://facebook.com/ ” 。浏览器自身定义 (User-Agent header)，并且声明浏览器能够接受什么类型的相应 (Accept and Accept-Encoding 头). Connection头要求服务器为了后边的请求不要关闭TCP连接。</p><p>请求中也包含浏览器存储的该域名的cookies。在不同页面请求当中，cookies是与跟踪一个网站状态相匹配的键值。cookies会存储登录用户名，服务器分配的密码和一些用户设置等。并以文本文档形式存储在客户机里，每次请求时发送给服务器。</p><h3 id="如何查看-http-请求" tabindex="-1"><a class="header-anchor" href="#如何查看-http-请求"><span>如何查看 HTTP 请求？</span></a></h3><p>用来看原始HTTP请求及其相应的工具很多。作者比较喜欢使用fiddler，当然也有像FireBug这样其他的工具。这些软件在网站优化时会帮上很大忙。</p><h3 id="post-请求" tabindex="-1"><a class="header-anchor" href="#post-请求"><span>POST 请求</span></a></h3><p>除了 GET 请求，还有一种是 POST 请求，它常在提交表单用到。GET 请求通过 URL传递其参数(e.g.: http://robozzle.com/puzzle.aspx?id=85 )。POST 请求在请求正文头之后发送其参数。</p><h3 id="末尾斜杠" tabindex="-1"><a class="header-anchor" href="#末尾斜杠"><span>末尾斜杠</span></a></h3><p>像 http://facebook.com/ 中的斜杠是至关重要的。这种情况下，浏览器能安全的添加斜杠。而像 http://example.com/folderOrFile 这样的地址，因为浏览器不清楚folderOrFile到底是目录还是文件，所以不能自动添加斜杠。这时，浏览器就不加斜杠直接访问地址，服务器会响应一个重定向，结果造成一次不必要的握手。</p><h2 id="_4-重定向响应" tabindex="-1"><a class="header-anchor" href="#_4-重定向响应"><span>4.重定向响应</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image8.png" alt="Redirect"></p><p>图中所示为Facebook服务器发回给浏览器的响应：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>HTTP/1.1 301 Moved Permanently</span></span>
<span class="line"><span> Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</span></span>
<span class="line"><span> pre-check=0</span></span>
<span class="line"><span> Expires: Sat, 01 Jan 2000 00:00:00 GMT</span></span>
<span class="line"><span> Location: http://www.facebook.com/</span></span>
<span class="line"><span> P3P: CP=&quot;DSP LAW&quot;</span></span>
<span class="line"><span> Pragma: no-cache</span></span>
<span class="line"><span> Set-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT;</span></span>
<span class="line"><span> path=/; domain=.facebook.com; httponly</span></span>
<span class="line"><span> Content-Type: text/html; charset=utf-8</span></span>
<span class="line"><span> X-Cnection: close</span></span>
<span class="line"><span> Date: Fri, 12 Feb 2010 05:09:51 GMT</span></span>
<span class="line"><span> Content-Length: 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“ http://www.facebook.com/ ” 而非“ http://facebook.com/ ”。</p><h3 id="为什么要重定向" tabindex="-1"><a class="header-anchor" href="#为什么要重定向"><span>为什么要重定向？</span></a></h3><p>为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？这个问题有好多有意思的答案。其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 http://www.igoro.com/ 和 http://igoro.com/ ,搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p><h2 id="_5-浏览器跟踪重定向地址" tabindex="-1"><a class="header-anchor" href="#_5-浏览器跟踪重定向地址"><span>5.浏览器跟踪重定向地址</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image23.png" alt="Follow"></p><p>现在，浏览器知道了 “ http://www.facebook.com/ ” 才是要访问的正确地址，所以它会发送另一个获取请求：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>GET http://www.facebook.com/ HTTP/1.1</span></span>
<span class="line"><span> Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]</span></span>
<span class="line"><span> Accept-Language: en-US</span></span>
<span class="line"><span> User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]</span></span>
<span class="line"><span> Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span> Connection: Keep-Alive</span></span>
<span class="line"><span> Cookie: lsd=XW[...]; c_user=21[...]; x-referer=[...]</span></span>
<span class="line"><span> Host: www.facebook.com</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>头信息以之前请求中的意义相同。</p><h2 id="_6-服务器-处理-请求" tabindex="-1"><a class="header-anchor" href="#_6-服务器-处理-请求"><span>6.服务器“处理”请求</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage9.png.pagespeed.ic.SAfiSgOdSs.webp" alt="handles"></p><p>服务器接收到获取请求，然后处理并返回一个响应。这表面上看起来是一个简单的任务，但其实这中间发生了很多有意思的事情。</p><h3 id="_6-1应用服务器" tabindex="-1"><a class="header-anchor" href="#_6-1应用服务器"><span>6.1应用服务器</span></a></h3><p>web服务器软件（如apache、tomcat）接收到HTTP请求，然后确定执行什么请求处理来处理它。请求处理就是一个能够读懂请求并且能生成HTML来进行响应的程序（像ASP.NET,PHP,RUBY...）。</p><p>举个最简单的例子，需求处理可以以映射网站地址结构的文件层次存储。像 http://example.com/folder1/page1.aspx 这个地 址会映射 /httpdocs/folder1/page1.aspx 这个文件。web服务器软件可以设置成为地址人工的对应请求处理，这样 page1.aspx 的发布地址就可以是 http://example.com/folder1/page1</p><h3 id="_6-2-请求处理" tabindex="-1"><a class="header-anchor" href="#_6-2-请求处理"><span>6.2 请求处理</span></a></h3><p>请求处理读取请求内容以及参数、cookies等信息。它会读取也可能更新一些数据，并将数据存储在服务器上。然后，需求处理会生成一个HTML响应。</p><h3 id="如何存储数据" tabindex="-1"><a class="header-anchor" href="#如何存储数据"><span>如何存储数据</span></a></h3><p>所有动态网站都面临一个有意思的难点——如何存储数据。小网站一半都会有一个SQL数据库来存储数据，存储大量数据和/或访问量大的网站不得不找一些办法把数据库分配到多台机器上（分表分库）。解决方案 有：sharding （基于主键值将数据表分散到多个数据库中），复制，利用弱语义一致性的简化数据库。</p><p>委托工作给批处理是一个廉价保持数据更新的技术。举例来讲，Fackbook得及时更新新闻feed，但数据支持下的“你可能认识的人”功能只需要每晚更新（作者猜测是这样的，该功能如何完善不得而知）。批处理作业更新会导致一些不太重要的数据陈旧，但能使数据更新耕作更快更简洁。</p><h2 id="_7-服务器发回一个html响应" tabindex="-1"><a class="header-anchor" href="#_7-服务器发回一个html响应"><span>7.服务器发回一个HTML响应</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image10.png" alt="response"></p><p>图中为服务器生成并返回的响应：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span> Cache-Control: private, no-store, no-cache, must-revalidate, post-check=0,</span></span>
<span class="line"><span> pre-check=0</span></span>
<span class="line"><span> Expires: Sat, 01 Jan 2000 00:00:00 GMT</span></span>
<span class="line"><span> P3P: CP=&quot;DSP LAW&quot;</span></span>
<span class="line"><span> Pragma: no-cache</span></span>
<span class="line"><span> Content-Encoding: gzip</span></span>
<span class="line"><span> Content-Type: text/html; charset=utf-8</span></span>
<span class="line"><span> X-Cnection: close</span></span>
<span class="line"><span> Transfer-Encoding: chunked</span></span>
<span class="line"><span> Date: Fri, 12 Feb 2010 09:05:55 GMT</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 2b3Tn@[...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个响应大小为35kB，其中大部分在整理后以blob类型传输。</p><p>内容编码头告诉浏览器整个响应体用gzip算法进行压缩。解压blob块后，你可以看到如下期望的HTML：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;!</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">DOCTYPE</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> html</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> PUBLIC</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> xmlns</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> http://www.w3.org/1999/xhtml </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> xml:lang</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">en</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lang</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">en</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> id</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">facebook</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> class</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> no_js</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">meta</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> http-equiv</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Content-type</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> content</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">text/html; charset=utf-8</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">meta</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> http-equiv</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Content-language</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> content</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">en</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于压缩，头信息说明了是否缓存这个页面，如果缓存的话如何去做，有什么cookies要去设置（前面这个响应里没有这点）和隐私信息等等。</p><p>请注意报头中把Content-type设置为“text/html”。报头让浏览器将该响应内容以HTML形式呈现，而不是以文件形式下载它。浏览器会根据报头信息决定如何解释该响应，不过同时也会考虑像URL扩展内容等其他因素。</p><h2 id="_8-浏览器开始显示html" tabindex="-1"><a class="header-anchor" href="#_8-浏览器开始显示html"><span>8.浏览器开始显示HTML</span></a></h2><p>在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了：</p><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/image6.png" alt="render"></p><h2 id="_9-请求其他对象" tabindex="-1"><a class="header-anchor" href="#_9-请求其他对象"><span>9.请求其他对象</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage11.png.pagespeed.ic.8hUNrIrxu9.webp" alt="embedded "></p><p>在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。</p><p>下面是几个我们访问facebook.com时需要重获取的几个URL：</p><ul><li>图片</li></ul><blockquote><p>http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif http://static.ak.fbcdn.net/rsrc.php/zBS5C/hash/7hwy7at6.gif …</p></blockquote><ul><li>CSS 式样表</li></ul><blockquote><p>http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css http://static.ak.fbcdn.net/rsrc.php/zANE1/hash/cvtutcee.css …</p></blockquote><ul><li>JavaScript 文件</li></ul><blockquote><p>http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js http://static.ak.fbcdn.net/rsrc.php/z6R9L/hash/cq2lgbs8.js …</p></blockquote><p>这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等...</p><p>但不像动态页面那样，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取。服务器的响应中包含了静态文件保存的期限 信息，所以浏览器知道要把它们缓存多长时间。还有，每个响应都可能包含像版本号一样工作的ETag头（被请求变量的实体值），如果浏览器观察到文件的版本 ETag信息已经存在，就马上停止这个文件的传输。</p><blockquote><p>试着猜猜看“fbcdn.net”在地址中代表什么？</p></blockquote><blockquote><p>聪明的答案是&quot;Facebook内容分发网络&quot;。Facebook利用内容分发网络（CDN）分发如图片，CSS表和JavaScript文件这些静态文件。所以，这些文件会在全球很多CDN的数据中心中留下备份。</p></blockquote><p>静态内容往往代表站点的带宽大小，也能通过CDN轻松的复制。通常网站会使用第三方的CDN。例如，Facebook的静态文件由最大的CDN提供商Akamai来托管。</p><p>举例来讲，当你试着ping static.ak.fbcdn.net的时候，可能会从某个akamai.net服务器上获得响应。有意思的是，当你同样再ping一次的时候，响应的服务器可能就不一样，这说明幕后的负载平衡开始起作用了。</p><h2 id="_10-浏览器发送异步-ajax-请求" tabindex="-1"><a class="header-anchor" href="#_10-浏览器发送异步-ajax-请求"><span>10.浏览器发送异步（AJAX）请求</span></a></h2><p><img src="http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage12.png.pagespeed.ic.Lh4dzFa1or.webp" alt="asynchronous "></p><p>在Web 2.0伟大精神的指引下，页面显示完成后客户端仍与服务器端保持着联系。</p><p>以 Facebook聊天功能为例，它会持续与服务器保持联系来及时更新你那些亮亮灰灰的好友状态。为了更新这些头像亮着的好友状态，在浏览器中执行的 JavaScript代码会给服务器发送异步请求。这个异步请求发送给特定的地址，它是一个按照程式构造的获取或发送请求。还是在Facebook这个例 子中，客户端发送给 http://www.facebook.com/ajax/chat/buddy_list.php 一个发布请求来获取你好友里哪个 在线的状态信息。</p><p>提起这个模式，就必须要讲讲&quot;AJAX&quot;-- “异步JavaScript 和 XML”，虽然服务器为什么用XML格式来进行响应也没有个一清二白的原因。再举个例子吧，对于异步请求，Facebook会返回一些JavaScript的代码片段。</p><p>除了其他，fiddler这个工具能够让你看到浏览器发送的异步请求。事实上，你不仅可以被动的做为这些请求的看客，还能主动出击修改和重新发送它们。AJAX请求这么容易被蒙，可着实让那些计分的在线游戏开发者们郁闷的了。（当然，可别那样骗人家~）</p><blockquote><p>Facebook聊天功能提供了关于AJAX一个有意思的问题案例：把数据从服务器端推送到客户端。因为HTTP是一个请求-响应协议，所以聊天服务器不能把新消息发给客户。取而代之的是客户端不得不隔几秒就轮询下服务器端看自己有没有新消息。</p></blockquote><blockquote><p>这些情况发生时长轮询是个减轻服务器负载挺有趣的技术。如果当被轮询时服务器没有新消息，它就不理这个客户端。而当尚未超时的情况下收到了该客户的新消息，服务器就会找到未完成的请求，把新消息做为响应返回给客户端。</p></blockquote><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="简单表述" tabindex="-1"><a class="header-anchor" href="#简单表述"><span>简单表述</span></a></h3><ol><li>输入网址</li><li>DNS查找目标ip</li><li>浏览器向目标ip地址发起tcp三次握手连接</li><li>连接建立后发起 http request</li><li>服务器处理 request</li><li>服务器返回一个 http response 给浏览器</li><li>浏览器将 response 内容显示在页面上</li></ol>`,93)]))}const r=a(t,[["render",p],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/networking/zmzq31bs/","title":"当你输入一个网址的时候，实际会发生什么?","lang":"zh-CN","frontmatter":{"title":"当你输入一个网址的时候，实际会发生什么?","comments":true,"categories":"计算机网络","tags":["计算机网络","HTTP"],"abbrlink":82216935,"createTime":"2018/01/19 15:17:10","permalink":"/networking/zmzq31bs/","description":"前言 一个 web 应用是如何运行的？作为软件开发者，我们必须得有一个完整的层次化的认知。这一篇将从浏览器，到 HTTP，HTML，web server，request handles 等方面切入，聊聊当我们输入一个网址的时候，后台到底发生了什么。 本文转载自：韩星的博客，对翻译进行了调整。 英文原文：what-really-happens-when-...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/networking/zmzq31bs/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"当你输入一个网址的时候，实际会发生什么?"}],["meta",{"property":"og:description","content":"前言 一个 web 应用是如何运行的？作为软件开发者，我们必须得有一个完整的层次化的认知。这一篇将从浏览器，到 HTTP，HTML，web server，request handles 等方面切入，聊聊当我们输入一个网址的时候，后台到底发生了什么。 本文转载自：韩星的博客，对翻译进行了调整。 英文原文：what-really-happens-when-..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://igoro.com/wordpress/wp-content/uploads/2010/02/image4.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"当你输入一个网址的时候，实际会发生什么?\\",\\"image\\":[\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image4.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image13.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/500pxAn_example_of_theoretical_DNS_recursion_svg.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image22.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image8.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image23.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage9.png.pagespeed.ic.SAfiSgOdSs.webp\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image10.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/image6.png\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage11.png.pagespeed.ic.8hUNrIrxu9.webp\\",\\"http://igoro.com/wordpress/wp-content/uploads/2010/02/ximage12.png.pagespeed.ic.Lh4dzFa1or.webp\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"1. 输入网址","slug":"_1-输入网址","link":"#_1-输入网址","children":[]},{"level":2,"title":"2. DNS查找","slug":"_2-dns查找","link":"#_2-dns查找","children":[{"level":3,"title":"DNS查找过程","slug":"dns查找过程","link":"#dns查找过程","children":[]},{"level":3,"title":"解决多个ip对应一个域名的问题","slug":"解决多个ip对应一个域名的问题","link":"#解决多个ip对应一个域名的问题","children":[]}]},{"level":2,"title":"3.发送HTTP请求","slug":"_3-发送http请求","link":"#_3-发送http请求","children":[{"level":3,"title":"如何查看 HTTP 请求？","slug":"如何查看-http-请求","link":"#如何查看-http-请求","children":[]},{"level":3,"title":"POST 请求","slug":"post-请求","link":"#post-请求","children":[]},{"level":3,"title":"末尾斜杠","slug":"末尾斜杠","link":"#末尾斜杠","children":[]}]},{"level":2,"title":"4.重定向响应","slug":"_4-重定向响应","link":"#_4-重定向响应","children":[{"level":3,"title":"为什么要重定向？","slug":"为什么要重定向","link":"#为什么要重定向","children":[]}]},{"level":2,"title":"5.浏览器跟踪重定向地址","slug":"_5-浏览器跟踪重定向地址","link":"#_5-浏览器跟踪重定向地址","children":[]},{"level":2,"title":"6.服务器“处理”请求","slug":"_6-服务器-处理-请求","link":"#_6-服务器-处理-请求","children":[{"level":3,"title":"6.1应用服务器","slug":"_6-1应用服务器","link":"#_6-1应用服务器","children":[]},{"level":3,"title":"6.2 请求处理","slug":"_6-2-请求处理","link":"#_6-2-请求处理","children":[]},{"level":3,"title":"如何存储数据","slug":"如何存储数据","link":"#如何存储数据","children":[]}]},{"level":2,"title":"7.服务器发回一个HTML响应","slug":"_7-服务器发回一个html响应","link":"#_7-服务器发回一个html响应","children":[]},{"level":2,"title":"8.浏览器开始显示HTML","slug":"_8-浏览器开始显示html","link":"#_8-浏览器开始显示html","children":[]},{"level":2,"title":"9.请求其他对象","slug":"_9-请求其他对象","link":"#_9-请求其他对象","children":[]},{"level":2,"title":"10.浏览器发送异步（AJAX）请求","slug":"_10-浏览器发送异步-ajax-请求","link":"#_10-浏览器发送异步-ajax-请求","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"简单表述","slug":"简单表述","link":"#简单表述","children":[]}]}],"readingTime":{"minutes":13.07,"words":3922},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"notes/networking/当你输入一个网址的时候，实际会发生什么.md"}');export{r as comp,h as data};
