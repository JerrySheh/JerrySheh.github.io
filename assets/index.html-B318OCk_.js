import{_ as t,c as n,f as a,a as l,b as i,d as h,e as p,r as k,o as r}from"./app-D22ydJtp.js";const d={};function g(c,s){const e=k("RouteLink");return r(),n("div",null,[s[3]||(s[3]=a(`<p>最近运维转发过来一封线上告警邮件，大概是说，我们负责的系统线上环境有一个接口隔一段时间就频繁报错，但持续十分钟左右就自动恢复了。从监控工具看到，每次报错出现时，都是同一台实例报出来的，此时其他实例是正常的，但下一次可能是另一台实例出现相同的问题，非常奇怪。</p><h2 id="问题特点" tabindex="-1"><a class="header-anchor" href="#问题特点"><span>问题特点</span></a></h2><p>收到这个邮件，我梳理了一下问题的特点：</p><ol><li>不定期出现，出现时间点没有规律，业务高峰期更多一些</li><li>一次持续十分钟左右</li><li>每次出问题的都是同一台实例，与此同时其他实例正常</li><li>每一台实例都可能出问题</li></ol><hr><h2 id="问题分析" tabindex="-1"><a class="header-anchor" href="#问题分析"><span>问题分析</span></a></h2><p>之后看了问题接口的逻辑，是从 db 查询一批资讯的数据，因为调用量比较大，所以设计了二级缓存。基本思想是先使用 redis 作为集中一级缓存，再使用 ehcache 作为本地二级缓存，若两级缓存都没有命中，再查询 db。与此同时，还有一个定时任务每10分钟定期把 db 的数据刷新到 redis 中，避免请求直接访问db。</p><p>根据问题特点，初步猜测问题很可能是出现在 ehcache 本地二级缓存中，因为若是代码逻辑有问题或者 redis 出现问题，应该所有实例同时都会有问题才对。</p><p>通过线上 error 日志和追踪工具分析发现，报错点是某一个字段报 <code>NullPointerException</code>，诡异的是，这个字段是受数据库查询条件约束的，正常情况下根本不可能为空。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- 以下SQL查询结果的 item 字段不可能为空</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> t.</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> info_table t</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> t</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">item</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> like</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">05%</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后在又一次复现时，查询了当时 db 和 redis 的数据，确定了该字段确实不为空，那么问题很明显只能出在 ehcache 本地缓存中了。此时另一位开发同事提醒我，这个缓存不仅仅是一个接口在使用，其他接口也可能用到。</p><p>于是问题原因就很明显了：其他接口拿到ehcache缓存的数据后，把缓存里的数据改掉了，导致这个接口从缓存中拿到了错误的数据。之后，定时任务又把正确的数据刷进缓存中，于是接口又自动恢复正常了。</p><hr><h2 id="问题原因" tabindex="-1"><a class="header-anchor" href="#问题原因"><span>问题原因</span></a></h2><p>走查代码发现，确实有另一个接口拿到ehcache缓存的数据后把数据改掉了，于是乎，暂时先把该缓存对象的开关关闭（还好当初开发时设计了开关），之后排期整改：<strong>从 ehcache 取出缓存数据后，如果要对数据进行修改，必须先进行一次深拷贝</strong>。</p>`,15)),l("p",null,[s[1]||(s[1]=i("至于深拷贝和浅拷贝的问题，之前也在 ")),h(e,{to:"/java/mpjlfomo/"},{default:p(()=>s[0]||(s[0]=[i("Java中的浅拷贝和深拷贝")])),_:1}),s[2]||(s[2]=i(" 这篇文章中分享过了。"))]),s[4]||(s[4]=a(`<hr><h2 id="从本地缓存和集中缓存取数据的区别" tabindex="-1"><a class="header-anchor" href="#从本地缓存和集中缓存取数据的区别"><span>从本地缓存和集中缓存取数据的区别</span></a></h2><p>我们知道，在 Java 中，在方法中声明的变量和引用都是在栈中分配的，不存在线程安全问题，除非通过参数传递进来或者直接使用类变量，才可能导致线程安全问题（一个线程访问的数据被另一个线程改了）。平时的开发中，从 redis 和数据库取数据，取出来的数据也不用担心线程安全问题。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> List</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Info</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> get1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> jedisUtils</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">info</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> List</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Info</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> get2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> jedisUtils</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">info</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像上面的例子，两个线程分别通过 <code>get1()</code> 和 <code>get2()</code>从 redis 取同一份数据，取出来的两个 list 是两份一模一样的数据，在堆内存中有两个一样的对象，不会互相影响。但同样的场景，换到从 ehcache 取就不一样了。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> List</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Info</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> get1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> cache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">info</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> List</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Info</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> get2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> cache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">info</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 ehcache 取出来的数据，如果你修改了 <code>get1()</code> 列表里面的数据，<code>get2()</code> 列表里的数据也会被修改，因为他们本质上是指向堆里的同一个对象。这也是为什么要用本地缓存的原因之一，减少重复内存占用，但如果开发时一不小心，修改了缓存里的对象，就会栽进坑里。</p><hr><h2 id="引申-缓存和cap原理" tabindex="-1"><a class="header-anchor" href="#引申-缓存和cap原理"><span>引申：缓存和CAP原理</span></a></h2><p>最近负责的这个项目的特点是接口访问量比较大，但提供的是一些产品和资讯的信息，对一致性的要求没有很高。所以很多接口都采用了 redis一级集中缓存 + ehcache二级本地缓存 + 定时任务定时刷新缓存 的方案。</p><p>使用本地二级缓存的优点是明显的，第一是减少网络传输开销，第二是减少一份数据多个地方使用时的内存占用（前提是不要修改），第三是一定程度减少缓存穿透问题。</p><p>但是如果我们在一个需要强一致性的场景中，那么直接使用集中式缓存可能会更好一点。如果非要加上本地缓存，要么用定时轮询+版本号的方式刷新本地缓存，要么使用消息队列主动通知，但这些手段最多也只能达到准实时，根据 CAP 原理，鱼和熊掌不可兼得。</p><p>说到 CAP 原理，我看过比较好的一篇文章是 <a href="https://zhuanlan.zhihu.com/p/338835258" target="_blank" rel="noopener noreferrer">CAP理论该怎么理解？为什么是三选二？为什么是CP或者AP？</a> ，可以作为引申阅读。</p>`,13))])}const y=t(d,[["render",g],["__file","index.html.vue"]]),A=JSON.parse('{"path":"/article/e4jtz7ge/","title":"从一次线上问题聊聊缓存使用","lang":"zh-CN","frontmatter":{"title":"从一次线上问题聊聊缓存使用","categories":["Java"],"tags":["Java"],"abbrlink":"4b7b6585","createTime":"2022/02/19 16:29:00","permalink":"/article/e4jtz7ge/","description":"最近运维转发过来一封线上告警邮件，大概是说，我们负责的系统线上环境有一个接口隔一段时间就频繁报错，但持续十分钟左右就自动恢复了。从监控工具看到，每次报错出现时，都是同一台实例报出来的，此时其他实例是正常的，但下一次可能是另一台实例出现相同的问题，非常奇怪。 问题特点 收到这个邮件，我梳理了一下问题的特点： 不定期出现，出现时间点没有规律，业务高峰期更多...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/article/e4jtz7ge/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"从一次线上问题聊聊缓存使用"}],["meta",{"property":"og:description","content":"最近运维转发过来一封线上告警邮件，大概是说，我们负责的系统线上环境有一个接口隔一段时间就频繁报错，但持续十分钟左右就自动恢复了。从监控工具看到，每次报错出现时，都是同一台实例报出来的，此时其他实例是正常的，但下一次可能是另一台实例出现相同的问题，非常奇怪。 问题特点 收到这个邮件，我梳理了一下问题的特点： 不定期出现，出现时间点没有规律，业务高峰期更多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"从一次线上问题聊聊缓存使用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"问题特点","slug":"问题特点","link":"#问题特点","children":[]},{"level":2,"title":"问题分析","slug":"问题分析","link":"#问题分析","children":[]},{"level":2,"title":"问题原因","slug":"问题原因","link":"#问题原因","children":[]},{"level":2,"title":"从本地缓存和集中缓存取数据的区别","slug":"从本地缓存和集中缓存取数据的区别","link":"#从本地缓存和集中缓存取数据的区别","children":[]},{"level":2,"title":"引申：缓存和CAP原理","slug":"引申-缓存和cap原理","link":"#引申-缓存和cap原理","children":[]}],"readingTime":{"minutes":4.9,"words":1471},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"posts/java/从一次线上问题聊聊缓存使用.md","categoryList":[{"id":"18958e","sort":10000,"name":"posts"},{"id":"8badbf","sort":10009,"name":"java"}]}');export{y as comp,A as data};
