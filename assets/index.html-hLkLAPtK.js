import{_ as n,c as e,f as a,o as l}from"./app-D22ydJtp.js";const i={};function c(p,s){return l(),e("div",null,s[0]||(s[0]=[a(`<p>使用 gcc 命令可以很方便地在Linux下编译C源代码，但是，当我们的工程变大了之后，项目下面有很多 <code>.c</code>、<code>.h</code>文件，各种依赖关系错综复杂。这时候，手工编译就不是那么划算了。makefile就是用于解决这个问题的。</p><p>假设我现在的工程下面有5个文件，分别是：</p><ol><li>main.c 主函数所在源文件</li><li>hello.c 输出hello的函数</li><li>hello.h 头文件</li><li>world.c 输出world的函数</li><li>world.h 头文件</li></ol><p>我们可以在工程目录下，新建一个名称为<code>makefile</code>的文件（没有扩展名），然后往这个文件里写一些规则，再在shell下面执行<code>make</code>命令，就可以实现自动编译了。</p><hr><h1 id="makefile的四种规则写法" tabindex="-1"><a class="header-anchor" href="#makefile的四种规则写法"><span>makefile的四种规则写法</span></a></h1><h2 id="一、显式规则" tabindex="-1"><a class="header-anchor" href="#一、显式规则"><span>一、显式规则</span></a></h2><p>makefile的规范：</p><p>目标 : 依赖 (tab)命令</p><ul><li>注意，命令前一定要是 TAB，不能是四个空格</li></ul><p>make的执行: make 默认搜索当前目录下的makefile，或者Makefile文件,可以指定特殊的makefile文件，比如 <code>make -f makefile_xxxx(文件名)</code></p><p>make默认实现makefile里的第一个目标，一般是二进制可执行文件 也可以指定目标，比如<code>make clean</code></p><p>一个简单的方法：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>main : main.o hello.o world.o</span></span>
<span class="line"><span>	gcc main.o hello.o world.o -o main</span></span>
<span class="line"><span></span></span>
<span class="line"><span>main.o : main.c hello.c world.c</span></span>
<span class="line"><span>	gcc -c main.c -o main.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>hello.o : hello.c</span></span>
<span class="line"><span>	gcc -c hello.c -o hello.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>world.o : world.c</span></span>
<span class="line"><span>	gcc -c world.c -o world.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean :</span></span>
<span class="line"><span>	rm *.o main</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p><ol><li>main是一个可执行文件（目标），它依赖于main.o hello.o world.o这三个文件（依赖），所以我们要用gcc编译main.o hello.o world.o，以生成main</li><li>我们的目录下现在还没有main.o hello.o world.o这三个文件，makefile会根据依赖文件 xxxx.o 去寻找和执行下面的依赖关系。以此类推。一步步生成上来。</li></ol><hr><h2 id="二、常量替换类似于c语言的宏定义" tabindex="-1"><a class="header-anchor" href="#二、常量替换类似于c语言的宏定义"><span>二、常量替换类似于C语言的宏定义</span></a></h2><p>为了方便，我们可以这样写makefile：</p><p>在前面使用编程语言的赋值语句<code>=</code>，定义变量</p><p>在使用变量的地方用<code>$(var)</code>的方式表示</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>cc 		= gcc</span></span>
<span class="line"><span>target 	= test</span></span>
<span class="line"><span>objects = test.o mystrlen.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$(target) : $(objects)</span></span>
<span class="line"><span>	$(cc) $(objects) -o $(target)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>test.o : test.c mystrlen.h</span></span>
<span class="line"><span>	$(cc) -c test.c -o test.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mystrlen.o : mystrlen.c</span></span>
<span class="line"><span>	$(cc) -c  mystrlen.c -o mystrlen.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean :</span></span>
<span class="line"><span>	rm $(objects) $(target)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="三、隐式规则" tabindex="-1"><a class="header-anchor" href="#三、隐式规则"><span>三、隐式规则</span></a></h2><p>还可以再精简：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>cc 		= gcc</span></span>
<span class="line"><span>target 	= test</span></span>
<span class="line"><span>headers = mystrlen.h</span></span>
<span class="line"><span>objects = test.o mystrlen.o</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$(target) : $(objects)</span></span>
<span class="line"><span>	$(cc) -o $(target) $(objects)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%.o : %.c $(headers)</span></span>
<span class="line"><span>	$(cc) -c $&lt; -o $@</span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean :</span></span>
<span class="line"><span>	rm $(objects) $(target)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="四、shell-隐式规则" tabindex="-1"><a class="header-anchor" href="#四、shell-隐式规则"><span>四、shell + 隐式规则</span></a></h2><p>结合shell命令，使用函数完成makefile，使其能够自动寻找目录下h文件和c文件，同时把c文件替换成o文件共object常量使用。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>cc = gcc</span></span>
<span class="line"><span>target = main</span></span>
<span class="line"><span>headers = $(shell find ./ -name &quot;*.h&quot;)</span></span>
<span class="line"><span>sources = $(shell find ./ -name &quot;*.c&quot;)</span></span>
<span class="line"><span>objects = $(sources:%.c=%.o)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$(target) : $(objects)</span></span>
<span class="line"><span>	$(cc) -o $(target) $(objects)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%.o : %.c $(headers)</span></span>
<span class="line"><span>	$(cc) -c $&lt; -o $@</span></span>
<span class="line"><span></span></span>
<span class="line"><span>clean:</span></span>
<span class="line"><span>	-rm -rf $(objects) $(target)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者是需要目录的地方可以用 shell 语句找出目录</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>obj-m = hello.o</span></span>
<span class="line"><span>all:</span></span>
<span class="line"><span>    make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules</span></span>
<span class="line"><span>clean:</span></span>
<span class="line"><span>    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="gcc常用参数" tabindex="-1"><a class="header-anchor" href="#gcc常用参数"><span>gcc常用参数</span></a></h1><ol><li>gcc -c main.c -o main.o 编译main.c,生成main.o目标文件</li><li>gcc test1.o test2.o -o test 链接两个目标文件test1.o和test2.o生成可执行文件test</li><li>gcc main.c -o main 编译main.c,然后链接生成main可执行文件</li><li>gcc main.c mystrlen.c hello.c -o main 编译多个文件</li><li>gcc -g main.c -o main 打开调试</li><li>gcc -I /usr/include main.c -o main 指定头文件目录</li><li>gcc -L /usr/lib -l ffmpeg main.c -o main 指定库文件目录和库文件libffmpeg.so</li><li>gcc -MM main.c 查看main.o 的依赖关系，用于生成makefile</li></ol>`,35)]))}const d=n(i,[["render",c],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/article/vzxtnfr7/","title":"了解makefile","lang":"zh-CN","frontmatter":{"title":"了解makefile","categories":"Linux","tags":["C/C++","Linux"],"abbrlink":"264103f9","createTime":"2017/11/28 09:15:30","permalink":"/article/vzxtnfr7/","description":"使用 gcc 命令可以很方便地在Linux下编译C源代码，但是，当我们的工程变大了之后，项目下面有很多 .c、.h文件，各种依赖关系错综复杂。这时候，手工编译就不是那么划算了。makefile就是用于解决这个问题的。 假设我现在的工程下面有5个文件，分别是： main.c 主函数所在源文件 hello.c 输出hello的函数 hello.h 头文件 ...","head":[["meta",{"property":"og:url","content":"https://jerrysheh.com/article/vzxtnfr7/"}],["meta",{"property":"og:site_name","content":"Jerry"}],["meta",{"property":"og:title","content":"了解makefile"}],["meta",{"property":"og:description","content":"使用 gcc 命令可以很方便地在Linux下编译C源代码，但是，当我们的工程变大了之后，项目下面有很多 .c、.h文件，各种依赖关系错综复杂。这时候，手工编译就不是那么划算了。makefile就是用于解决这个问题的。 假设我现在的工程下面有5个文件，分别是： main.c 主函数所在源文件 hello.c 输出hello的函数 hello.h 头文件 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-20T05:02:32.000Z"}],["meta",{"property":"article:tag","content":"C/C++"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:modified_time","content":"2024-10-20T05:02:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"了解makefile\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-20T05:02:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、显式规则","slug":"一、显式规则","link":"#一、显式规则","children":[]},{"level":2,"title":"二、常量替换类似于C语言的宏定义","slug":"二、常量替换类似于c语言的宏定义","link":"#二、常量替换类似于c语言的宏定义","children":[]},{"level":2,"title":"三、隐式规则","slug":"三、隐式规则","link":"#三、隐式规则","children":[]},{"level":2,"title":"四、shell + 隐式规则","slug":"四、shell-隐式规则","link":"#四、shell-隐式规则","children":[]}],"readingTime":{"minutes":2.92,"words":876},"git":{"createdTime":1729400552000,"updatedTime":1729400552000,"contributors":[{"name":"jerrysheh","email":"jerrysheh@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"posts/linux/了解makefile.md","categoryList":[{"id":"18958e","sort":10000,"name":"posts"},{"id":"decce4","sort":10015,"name":"linux"}]}');export{d as comp,r as data};
