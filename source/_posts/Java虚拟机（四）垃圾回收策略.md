---
title: Java虚拟机（四）垃圾回收策略
comments: true
categories: JAVA
tags: Java
abbrlink: 2191536a
date: 2018-08-10 21:32:32
---

在 [Java虚拟机（二）内存模型和对象创建](../post/7a1af8ce.html) 这一篇中，我们知道 Java 虚拟机的内存模型包含五个部分：程序计数器、Java虚拟机栈、本地方法栈、堆、方法区。这五个区域也叫运行时数据区域（Runtime Data Area），他们是数据的存储空间。既然是存储空间，那就有可能达到存满的时候，因此，JVM必须配备一个垃圾回收器（Garbage Collection, GC），用于不定期地回收不再需要的内存空间。


<!-- more -->

---

# 线程私有区域

程序计数器、Java虚拟机栈、本地方法栈都是线程私有的，这三个区域会随着线程的创建而创建，随着线程的结束而销毁。

此外，Java虚拟机栈、本地方法栈中的栈帧会随着方法的开始而入栈，随着方法的结束而出栈，每个栈帧中的本地变量表都是在类被加载的时候就确定的。

正是因为这些确定性，垃圾回收器能够清楚地知道何时该回收这部分内存空间。

---

# 线程共享区域

堆和方法区是所有线程共享的，并且都在JVM启动时创建，一直运行到JVM停止。

堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象实例只有在程序运行期间才能确定。

方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。

因此，堆和方法区的内存回收具有不确定性，因此垃圾收集器在回收堆和方法区内存的时候就不那么容易了。

---

# 堆内存的回收

## 判断哪些对象需要回收

一个对象不被任何对象或变量引用，那么就是无效对象，就需要被回收。可以用 引用计数法 和 可达性分析法 来找到无效对象。

### 引用计数法

每个对象都有一个计数器，当这个对象被一个变量或另一个对象引用一次，该计数器加一；若该引用失效则计数器减一。当计数器为0时，就认为该对象是无效对象。

引用计数法虽然简单，但存在一个严重的问题，它无法解决循环引用的问题。因此，目前主流语言均使用可达性分析方法来判断对象是否有效。

### 可达性分析法

GC把以下几种对象称为 GC Roots：

1. Java虚拟机栈所引用的对象(栈帧中局部变量表中引用类型的变量所引用的对象)
2. 本地方法栈所引用的对象
3. 方法区中静态属性和常量引用的对象

可达性分析法的规则是：所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。

GC Roots并不包括堆中对象所引用的对象！这样就不会出现循环引用。

## 回收过程

1. 判断该对象是否 Override 了 `finalize()` 方法，若有 Override，将 `finalize()` 扔进F-Queue队列中；若无 Override，直接释放对象内存；
2. 执行F-Queue队列中的 `finalize()` 方法；
3. 如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。

> 强烈不建议使用 finalize() 函数进行任何操作！如果需要释放资源，请使用try-finally。因为 finalize() 不确定性大，开销大，无法保证顺利执行。

---

# 方法区的回收

方法区中主要清除两种垃圾：
1. 废弃常量
2. 废弃的类

## 如何判定废弃常量？

清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。

## 如何废弃废弃的类？

1. 该类的所有对象都已被清除
2. 该类的 java.lang.Class 对象没有被任何对象或变量引用
3. 加载该类的 ClassLoader 已经被回收

---

# 垃圾回收算法

## 1. 标记-清除算法

首先判断需要清除哪些数据，并给它们做上标记，然后清除被标记的数据。

### 效率分析

这种方法效率比较低，而且清除完后存在大量碎片空间，导致无法存储大对象，降低了空间利用率。

## 2. 复制算法

将内存分成两份，只将数据存储在其中一块上。当需要回收垃圾时，也是首先标记出废弃的数据，然后将有用的数据复制到另一块内存上，最后将第一块内存全部清除。

### 效率分析

这种算法避免了碎片空间，但内存被缩小了一半。而且每次都需要将有用的数据全部复制到另一片内存上去，效率不高。

### 复制算法如何解决空间利用率问题？

在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，因此我们可以将内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1。分配内存时，只使用Eden和一块Survior1。当发现Eden+Survior1的内存即将满时，JVM会发起一次MinorGC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。

通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。

但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程称为“分配担保”。

## 3. 标记-整理算法

在回收垃圾前，首先将所有废弃的对象做上标记，然后将所有未被标记的对象移到一边，最后清空另一边区域即可。

### 效率分析

这是一种针对老年代的算法，因为老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活。其清空的是标记的废弃对象区域。

## 4. 分代收集算法

将内存划分为老年代和新生代。老年代中存放寿命较长的对象，新生代中存放“朝生夕死”的对象。然后在不同的区域使用不同的垃圾收集算法。

---

# Java中引用的种类

Java中跟垃圾回收密切相关的就是引用的类型了，这一部分之前专门有写了一篇 [Java中的引用类型](../post/ae9388fa.html)，现在回过头来看，好像又加深了一些理解。

---

参考：

- [深入理解JVM(三)——垃圾收集策略详解](https://blog.csdn.net/u010425776/article/details/51189318)
-
