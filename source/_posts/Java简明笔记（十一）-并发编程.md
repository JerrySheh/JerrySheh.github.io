---
title: Java简明笔记（十一） 并发编程艺术
comments: true
categories: JAVA
tags: Java
abbrlink: 727d207c
date: 2018-03-01 00:29:51
---

# 问题的来源

最开始的时候，计算机都只有一个 CPU 并且一次只能执行一个程序。后来出现了 **多任务（multitasking）** 使得计算机可以同时执行多个程序，但这并不是真正的“同时”，只是把 CPU 分成多个时间片，由操作系统去调度切换。再之后出现了 **多线程（multithreading）** 使得在一个程序里面可以同时执行线程，就像你有多个 CPU 在执行同一个程序一样。在单 CPU 的计算机中，多线程的“同时”并不是“同时”，但现代计算机一般都是多核 CPU，意味着不同的线程可以被不同的 CPU 核心同时执行，是真正的同时。

![multithreading](http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png)

如果一个线程在读一块内存区域的同时，另一个线程在往里面写，那么这块区域的值是什么？或者两个线程同时写一块内存区域，它的值又是什么？假如我们没有对这些可能出现的结果进行防范，那么结果将是不可预测的。什么情况都可能发生。因此，我们需要在一些共享资源上做一些措施，例如内存、文件、数据库等。

<!-- more -->

---

# 多线程的利弊

## 利

1. **更好的资源利用**：多线程程序在一个线程加载 IO 的同时，另一个线程可以处理已经加载完毕的 IO，以节省时间。
2. **简化程序设计**：单线程程序，既要负责加载IO，又要负责处理。多线程程序，可以让一个线程专门加载，另一个线程专门处理。程序逻辑更加清晰。
3. **更加高效的程序**：当一个请求进来时，处理请求可能需要耗费一些时间。单线程程序这时候就无法接收新的请求了，而多线程程序一个线程负责接收请求，每次收到请求都开一个专门的线程去处理，实现了多请求。

## 弊

1. **更加复杂的设计**：多线程有时候会让程序变得更加复杂（complex）。
2. **上下文切换消耗**：CPU从一个线程切换到另一个线程时，要先保存上一个线程的 local data，程序指针等。这会带来一些消耗。
3. **提高资源消耗**：多线程本身需要一些内存用于存储其 local stack，这可能消耗一些内存资源。不要以为它很小，实际上可能比你想象的多。

---

# 并发模型（Concurrency Models）

并发模型指的是线程如何在系统中协同完成一项工作。不同的并发系统可以用不同的并发模型来实现。

## 并发模型和分布式系统的相似性

值得一提的是，本文中涉及的并发系统模型跟分布式系统（distributed systems）十分相似。例如，并发系统中是不同的线程之间互相通讯（communicate），而分布式系统是不同的进程之间互相通讯（这些进程可能在不同的计算机上）。进程和线程在某些时候十分相似，这也是为什么不同的并发模型往往看起来都很像分布式系统架构。此外，分布式系统需要面临网络请求可能失败、远程计算机或进程可能挂掉等问题，在并发系统中也会遇到类似 CPU 故障、网卡故障、硬盘故障等问题，这些故障发生的概率很低，但理论上确实存在。

正因为并发模型和分布式系统十分相似，因此他们之间有些设计思想是相通的。例如，并发里面用于分配 workers （threads）的模型，就类似于分布式系统的负载均衡（load balancing in distributed systems）。

## 模型1：并行 Workers

![parallel workers](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png)

在这个模型中，每一个 Worker（Thread）都由 delegator 来委派。每一个 Worker 都完成一个完整的工作。例如，在一个车间工厂，一辆车从零到一都只由一个 Worker 来完成。

这种模型在 Java 中用得非常多。在 java.util.concurrent 包中，许多的并发工具都是用这个模型来设计的。在 J2EE 应用服务器中也能看到这种模型的影子。

### 并行 Workers 的优缺点

优点很明显，例如一个多线程爬虫可以同时爬取多个页面，你只需要多开几个线程，就可以得到明显的效率提升。而这种模型也潜在着一些缺点。首先是共享区域，多个 workers 可能经常需要访问一片共享数据，包括内存和数据库。这导致了三个问题。

![](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png)

1. **可见性问题**：当一个线程改动了这片共享区域的数据，要确保另一个线程能够及时的看到改变（改变应该及时放进主存里，而不是在执行当前线程的 CPU 的临时寄存器）
2. **竞争条件**：许多并发数据结构是阻塞的，也就是说，一次只能有一个或少量线程能够访问。这会导致多线程去争夺这个资源。高争夺导致了共享数据结构一定程度上的序列化执行，而不是并发执行。即使现代非阻塞并发算法能够减少竞争，但是这些算法通常是难以实现的。
3. **死锁**：
