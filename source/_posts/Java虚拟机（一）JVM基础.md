---
title: Java虚拟机（一）JVM 类加载器
comments: true
categories: JAVA
tags: Java
abbrlink: 3ebede8
date: 2018-08-04 12:53:58
---

# 什么是Java虚拟机

我们知道，Java的理念是“一次编译，到处运行”。我们平时编写的 Java 代码，经过Java编译器编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机（Java Virtual Machine，JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行的软件，其本身是由C/C++编写。

## JVM 如何让 Java 程序跨平台？

JVM 将字节码翻译成机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。

而这个过程，我们编写的 Java 程序没有任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。需要注意的是，JVM 本身是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM。

![JVM](../../../../images/Java/JVM.png)

<!-- more -->

---

# JVM的组成

JVM由四个部分组成：

- **类加载器**：JVM 启动时或者类运行时将需要的 class 加载到 JVM 中
- **执行引擎**：执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU
- **内存区域**：将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块
- **本地方法调用**：调用 C 或 C++ 实现的本地方法的代码返回结果

![JVM_component](../../../../images/Java/JVM_component.png)

---

# 类加载器

## 类加载器的作用

编译器生成的许多 .class 字节码文件，其实就是一个个的 Java 类。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance() 方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。

## 类加载器如何加载 class 文件？（即把一个类装入JVM）

在Java中，ClassLoader 把一个类装入JVM的步骤如下：

![classloader](../../../../images/Java/load.png)

### 加载

加载就是查找和导入Class文件的过程。在这个过程，JVM需要完成三件事：

1. **获取二进制字节流**：通过一个类的全限定名来获取其定义的二进制字节流
2. **静转动**：将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. **生成Class类对象**：在堆内存中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口

在加载阶段，开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。

### 链接

在这个阶段，JVM需要完成三件事：

1. **校验**：检查载入的Class文件正确性，包含文件格式验证、元数据验证、字节码验证和符号引用验证
2. **准备**：给类的静态变量分配内存并初始化为默认值，此时还未赋值。
3. **解析**：将符号引用转化成直接引用。（符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。）

### 初始化

对类的静态变量和静态代码块进行赋值。例如我们在程序中编写：

```java
public static final int value = 3;
```

在加载阶段， value 还是 0， 在初始化阶段，value 就被赋值为 3 了。

初始化的步骤如下：

1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
3. 假如类中有初始化语句，则系统依次执行这些初始化语句

## 全盘负责委托机制

类加载器 ClassLoader 是具有层次结构的，也就是父子关系。

![classloader](../../../../images/Java/classloader.png)

JVM装载类时，使用了“全盘负责委托机制”：

- **全盘负责**：当一个 ClassLoader 装载一个类时，该类所依赖及引用的类也由该 ClassLoader 载入。
- **委托机制**：先委托父装载器寻找目标类，找不到时才从自己的类路径找。

之所以这样设计，是从安全角度考虑的，试想如果有人恶意编写了一个 java.lang.String 类并装载到 JVM 中，我们使用 String 的时候就可能执行了他的 String 而不是 Java 提供的 Stirng了。有了全盘负责委托机制，java.lang.String 永远是由根装载器来装载，避免了上述安全隐患。

## 类加载器如何判断两个 Java 类是相同的  ？

**Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。** 只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。

比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。
