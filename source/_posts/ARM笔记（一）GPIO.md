---
title: ARM笔记（一）GPIO
categories: ARM基础
tags: ARM
abbrlink: 10ae863d
date: 2017-09-30 17:06:58
update: 2017-10-01 10:26:01
---

想了很久还是决定开坑，虽然目前对嵌入式还没有太大的兴趣。本来对 《ARM嵌入式系统概论》 这门课只是想水过去，但是郝老师说得也对，在还不明确自己真正深入热爱的东西的时候，多学点东西，多长长见识，总是没坏处的。正像当初学了 Python 的基本语法，却一直无“用武之地”，没想到最近搞 CTF 时，需要写一些简单的 Python 脚本辅助解题，庆幸自己了解过一点 Python 基础语法。所以，不多说，开始吧。

笔记的参考教材为《ARM嵌入式系统基础教程》（周立功主编，第二版），以LPC2000系列为例。

![LARM](../../../../images/学ARM.jpg)

笔记（一）涉及到的知识：
1. GPIO的引脚连接
2. GPIO的相关寄存器

---

<!-- more -->



# 引脚连接模块

LPC2000系列微控制器的大部分管脚都具有多种功能，即管脚复用，但是同一引脚在同一时刻只能使用其中一个功能，通过配置相关寄存器控制多路开关来连接引脚与片内外设。

* LPC2000系列中，外部存储器寄存器 PINSEL0 和 PINSEL1 用来配置引脚连接


PINSEL0 有 16 个引脚，分别为 p0.0 - p0.15，每个引脚占用 2 位，共 32 位

PINSEL1 也有 16 个引脚，分别为 p0.16 - p0.31，每个引脚占用 2 位，共 32 位

功能如下表：

 PINSEL0

![PINSEL0](../../../../images/PINSEL0.png)

 PINSEL1

![PINSEL1](../../../../images/PINSEL1.png)

## 使用方法

例如，要将 PINSEL1 寄存器 的 p0.20 设为 EINT3（中断）功能，只需要把第8，第9位设为 1

```c
PINSEL1 = 3 << 8
```

说明：
3 << 8 意思为 3 左移 8 位，3 的二进制数是 11 ，左移 8 位相当于在右边补8个0，即变成 11 0000 0000，从最右边从0数起，“11” 为第8，第9位，意思是，把 PINSEL1 的第8，第9位设置为 1。


位数 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0
---|---
值 | 1 |1|0|0|0|0|0|0|0|0
上表只写出 0-9位，实际上是 32 位，第10-31位就不写出来了。

查上 PINSEL1 表知道，PINSEL1 的第8，第9位对应的引脚正是 p0.20， 当第8，第9位的值为 11 时， 其功能为EINT3，因此，这句语句就将 PINSEL1 寄存器 的 p0.20 设为了 EINT3 功能。




---
# GPIO的相关寄存器

## 1. IOxPIN

功能： 用来读引脚当前的状态


## 2. IOxDIR

功能：用来设置 GPIO 的方向， 输入 = 0， 输出 = 1


## 3. IOxSET

功能：用来输出高电平


## 4. IOxCLR

功能：用来输出低电平


## 一个实例：设置 PINSEL0 的 p0.0 引脚输出高电平

```c
PINSEL0 &= 0xFFFFFFFC;
IO0DIR  |= 0x00000001;
IO0SET   = 0x00000001;

```
说明：
0. 0x开头是十六进制数
1. PINSEL0 &= 0xFFFFFFFC 意思是把第0，第1位设为0，第2-31位设为1。
2. IO0DIR  |= 0x00000001 把第0设为输出
3. IO0SET   = 0x00000001 把第0位设为高电平
4. &= 和 |= 是为了让其他位保持不变，至于为什么可查阅C语言符号运算相关资料

---
# 附录：

## 一个延时函数

```c
void  DelayNS(uint32  dly)
{   uint32  i;
    for(; dly>0; dly--)
    {
        for(i=0; i<5000; i++);
    }
}

```

## 一个让蜂鸣器响的例子

```c
#define   BEEPCON  0x00000080       // P0.7引脚控制B1，低电平蜂鸣
int  main(void)
{  
    PINSEL0 = 0x00000000;       // 设置管脚连接GPIO   
    IO0DIR = BEEPCON;           // 设置I/O为输出
    while(1)
    {  
        IO0SET = BEEPCON;       
        DelayNS(15);
        IO0CLR = BEEPCON;       // BEEPCON = 0
        DelayNS(15);
    }
    return(0);
}

```
