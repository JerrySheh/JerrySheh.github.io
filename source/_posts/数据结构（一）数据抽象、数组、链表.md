---
title: 数据结构（一）数据抽象、数组、链表
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: a7047cb5
date: 2017-11-23 23:06:46
---

# 数据抽象

在开始谈数据结构之前，先聊一聊什么是`数据抽象`和`抽象数据类型（ADT）`。

数据类型是指 **一组值** 和 **一组对这些值的操作** 的集合，Java中有多种 **原始数据类型**，如int。int是 `-2^31` 到 `2^31 - 1` 之间的这些整数值，以及加、减、乘、除等这些操作的集合。理论上所有程序只需要使用这些原始数据类型(int double char等)即可，但如果我们能把原始数据类型抽象成更高级的数据类型（string queue stack等），无疑会更加方便程序的编写。

<font color="red">我们把定义和使用我们自己的数据类型的这个过程，叫做数据抽象。 </font>


**抽象数据类型（ADT）** 是一种能够对使用者隐藏数据表示的数据类型。它将数据和函数的实现关联，并将数据的表示方式隐藏起来。我们在使用抽象数据类型时，主要关注如何操作而不关心数据本身是怎么表示的。也就是说，使用一个抽象数据类型，并不需要了解其实现细节。

![ADT](../../../../images/ADT.png)

<!-- more -->

---

# 三种简单的集合类数据类型

## 背包

背包是一种不支持从中删除元素的集合数据类型。它主要用于帮助用例收集元素，然后遍历这些的元素。这些元素没有顺序。

## 队列

队列是一种先进先出（FIFO）策略的集合类型。

## 栈

栈是一种后进先出（LIFO）策略的集合类型。栈的应用非常广泛，例如几乎每个编辑器都有的Undo操作（撤销）、操作系统中的程序调用栈、括号/符号匹配等等。

### 栈的典型应用

1. 逆序输出（十进制转其他进制）
2. 括号匹配

> Dijkstra双栈算式表达式求值法，将操作数和运算符分别放入两个栈中，遇到左括号“（” 则忽略，遇到操作数则将操作数压入栈1中，遇到运算符将它压入栈2中，遇到右括号，则弹出运算符和操作数，计算结果后重新压入栈中。

### 如何用两个栈实现一个队列？

添加时往A栈添加。删除时，先判断B栈是否为空，如果非空，直接从B栈取出最顶元素删除，如果为空，先把A栈里的元素全部倒入B栈中，然后删除最顶元素。

## 什么是对象的游离

在一个栈中，当我们使用`pop()`弹栈的时候，被弹出的元素我们再也不需要用到它了。但它的引用还存在于数组中。这种情况就称为游离。在 Java 中，避免对象游离很容易，只需将其设为 null 即可。这样系统（Java垃圾回收策略）就可以在使用完后将其回收。

---

# 数组

背包、队列和栈是三种简单的数据类型。那么我们如何去组织上述的数据类型呢？这时候就要用到数组和链表了。这里先介绍数组：

数组，简单来说就是将所有的数据排成一排存放在系统分配的一个内存块上，通过使用特定元素的索引作为数组的下标，可以在常数时间内访问数组元素的这么一个结构。

![](../../../../images/DataStructure/array.png)

## 数组的优点

- 简单、易用
- 访问元素快（常数时间）

## 数组的缺点

- **大小固定**：数组在使用前必须先制定固定的大小，可能会造成浪费或者不够用溢出
- **连续空间块**：数组初始分配空间时，有时候无法分配能存储整个数组的内存空间（当数组规模太大时）
- **插入操作实现复杂**：往一个大数组中间插入数据，插入索引后面的数据都要相应地往后移动，这会造成很大的开销


## 算法1.1 下压（LIFO）栈的数组实现（能够动态调整数组大小的实现）

```Java
import java.util.Iterator;

public class ResizingArrayStack<Item> implements Iterable<Item> {
    //栈元素
    private Item[] a = (Item[]) new Object[1];  

    //元素数量
    private int N = 0;      

    //判断是否为空                    
    public boolean isEmpty(){ return N == 0; }

    //栈的大小
    public int size(){ return N; }

    //将栈移动到一个大小为max的新数组
    private void resize(int max){               
        Item[] temp = (Item[]) new Object[max];
        for (int i = 0; i < N; i++) {
            temp[i] = a[i];
        }
        a = temp;
    }

    //将元素添加到栈顶
    public void push(Item item){               
        if (N==a.length) resize(2*a.length);
        a[N++] = item;
    }

    // 弹栈
    public Item pop(){
        Item item = a[--N];
         //避免对象游离
        a[N] = null;        
        if ( N >0 && N == a.length/4) resize(a.length/2);
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ReverseArrayIterator();
    }

    public class ReverseArrayIterator implements Iterator<Item> {
        private int i = N;

        public boolean hasNext() {
            return i > 0;
        }

        public Item next() {
            return a[--i];
        }

        public void remove() {
        }
    }
}
```

---

# 四、什么是链表

链表是一种递归的数据结构。它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。对于链表来说，初始时仅需要分配一个元素的存储空间。添加新的元素也很容易，不需要做任何内存复制和重新分配的操作。

## 链表的优点

- 动态，大小不固定
- 离散，在内存空间里存储不必连续

## 链表的缺点

- 没有随机访问的能力，访问一个元素必须先访问它的上一个元素
- 链表中的额外指针引用需要浪费内存

## 链表操作

### 1. 定义结点

```java
private class Node{
  Item item;
  Node next;
}
```

### 2. 访问链表

如果有一个链表的对象实例 `first`，那么我们可以用 `first.item` 和 `first.next` 访问它的实例变量。


### 3. 构造链表

```java
//创建三个链表对象实例
Node first = new Node();
Node second = new Node();
Node third = new Node();

//每个实例的值
first.item = "to";
second.item = "be";
third.item = "or";

//指向下一个实例
first.next = second;
second.next = third;
```

我们先 new 了三个链表对象实例，然后给他们的Item赋值，并让他们的next指向下一个链表的引用。（链表是递归的数据结构）

在这里，`third.next`是null，也就是`third.next`指向了一个空链表。

链表表示的是一列元素。

### 4. 在表头插入结点

```java
//步骤一：保存原来的表头
Node oldfirst = first;

//步骤二：创建新的首结点
first = new Node();

//步骤三：设置新结点的实例变量
first.item = "not";
first.next = oldfirst;
```

### 5. 删除头结点

```java
first = first.next;
```

## 6. 在表尾插入结点

```java
//步骤一：保存指向尾结点的链接
Node oldlast = last;

//步骤二：创建新的尾结点
last = new Node();
last.item = "not";

//步骤三：将尾链接指向新结点
oldlast.next = last;

```

---

# 算法1.2 下压堆栈（链表实现）

```java
import java.util.Iterator;

public class Stack<Item> implements Iterable<Item>{
    //栈顶
    private Node first;  

    // 元素数量
    private int N;       

    //定义结点
    private class Node{  
        Item item;
        Node next;
    }

    // 判断栈是否为空
    public boolean isEmpty(){ return N == 0;}

    // 栈的大小
    public int size(){ return N;}

    //向栈顶添加元素
    public void push(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }

    //从栈顶删除元素
    public Item pop(){
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }

    //实现迭代
    public Iterator<Item> iterator(){ return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext(){ return current != null; }
        public void remove(){ }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}
```


# 算法1.3 先进先出队列(链表实现)

```java
import java.util.Iterator;

public class Queue<Item> {
    //指向最早添加的结点的链接
    private Node first;  

    //指向最近添加的结点的链接
    private Node last;   

    // 元素数量
    private int N;       

    //定义结点
    private class Node{  
        Item item;
        Node next;
    }

    // 判断队列是否为空
    public boolean isEmpty(){ return first == null;}

    // 队列的大小
    public int size(){return N;}

    //向表尾添加元素
    public void enqueue(Item item){
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else oldlast.next = last;
        N++;
    }

    //从表头删除元素
    public Item dequeue(){
        Item item = first.item;
        first = first.next;
        if (isEmpty()) last = null;
        N--;
        return item;
    }

    //实现迭代
    public Iterator<Item> iterator(){ return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext(){ return current != null; }
        public void remove(){ }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}
```
