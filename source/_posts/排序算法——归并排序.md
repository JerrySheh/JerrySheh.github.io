---
title: 排序算法——归并排序
date: 2017-12-07 17:00:28
tags: 数据结构和算法
---

# 一、归并排序简介

要将一个有16个元素的数组排序，可以先将它分成两半，每一半8个元素，分别排序，然后将排序好的两个8元素的结果归并起来。

要将一个有8个元素的数组排序，可以先将它分成两半，每一半4个元素，分别排序，然后将排序好的两个4元素的结果归并起来。

要将一个有4个元素的数组排序，可以先将它分成两半，每一半2个元素......


基于这种思想的排序，就是归并排序。

![MergeSort1](../../../../images/MergeSort1.png)

![MergeSort2](../../../../images/MergeSort2.png)


<!-- more -->

 ---

# 二、如何归并

从上面的图可以看到，第一步是分治，即不断地把长数组拆分成两半，直到只有2个了，再排大小。

第二步是归并，把很多个排好的两半，重新拼接起来，拼到最后，就把所有元素排序好了。

那么，我们如何实现第二步的归并呢？

我们假设原来要排序的数组为a[]， 我们可以先将a[] 全部复制到辅助数组 aux[] 中。然后依次判断：
1. 左半边是否用尽，如果用尽，取右半边的元素，否则2
2. 右半边是否用尽，如果用尽，取左半边的元素，否则3
3. 右半边的当前元素是否小于左半边的当前元素，如果是，取右半边的元素，否则取左半边的元素

```java
//归并
public static void merge(Comparable[] a, int low, int mid, int high){
    int i = low;
    int j = high;

    //将a[] 全部复制到辅助数组 aux[] 中
    for (int k = low; k <= high; k++) {
        aux[k] = a[k];
    }

    //4次判断
    for (int k = low; k <= high; k++) {
        if      ( i > mid  )          a[k] = aux[j++];
        else if ( j > high )          a[k] = aux[i++];
        else if (less(aux[j],aux[i])) a[k] = aux[j++];
        else                          a[k] = aux[i++];

    }
}
```


 ---

# 算法2.4 自顶向下的归并排序

```java
public class MergeSort {
    private static Comparable[] aux;

    public static void sort(Comparable[] a){
        aux = new Comparable[a.length];    //一次性分配空间
        sort(a,0,a.length-1);
    }

    public static void sort(Comparable[] a, int low, int high){
        if (high <= low) return;
        int mid = low + (high-low)/2;
        sort(a,low,mid);         // 排序左半边
        sort(a,mid+1,high); // 排序右半边
        merge(a,low,mid,high);   // 左右两边归并
    }

    //归并
    public static void merge(Comparable[] a, int low, int mid, int high){
        int i = low;
        int j = high;

        //将a[] 全部复制到辅助数组 aux[] 中
        for (int k = low; k <= high; k++) {
            aux[k] = a[k];
        }

        //4次判断
        for (int k = low; k <= high; k++) {
            if      ( i > mid  )          a[k] = aux[j++];
            else if ( j > high )          a[k] = aux[i++];
            else if (less(aux[j],aux[i])) a[k] = aux[j++];
            else                          a[k] = aux[i++];

        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }
}

```
