---
title: 数据结构（三）归并排序算法
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: 4e99e3ae
date: 2017-12-07 17:00:28
---

# 一、归并排序简介

要将一个有16个元素的数组排序，可以先将它分成两半，每一半8个元素，分别排序，然后将排序好的两个8元素的结果归并起来。

要将一个有8个元素的数组排序，可以先将它分成两半，每一半4个元素，分别排序，然后将排序好的两个4元素的结果归并起来。

要将一个有4个元素的数组排序，可以先将它分成两半，每一半2个元素......


基于这种思想的排序，就是归并排序。

![MergeSort1](../../../../images/MergeSort1.png)

![MergeSort2](../../../../images/MergeSort2.png)


<!-- more -->

 ---

# 二、实现思路

从上面的图可以看到，归并排序的两个步骤：

## 第一步：分治

即不断地把长数组拆分成两半，直到只有2个了，再排大小。

实现分治非常简单，用递归调用自己，大数组自然会被划分到最小：

```java
public static void mergeSort(int[] arr, int low, int high){
    if (high <= low ) return;

    // 找到中间点
    int mid = (low + high) / 2;

    // 排序左半边
    mergeSort(arr, low, mid);

    // 排序右半边
    mergeSort(arr, mid+1, high);

    // 左右两边归并
    merge(arr, low, mid, high);
}
```

## 第二步：归并

把很多个排好的两半，重新拼接起来，拼到最后，就把所有元素排序好了。

如何实现呢？

假设原来要排序的数组为a[]，可以先将a[] 全部复制到辅助数组 aux[] 中。然后依次判断：
1. 左半边是否用尽，如果用尽，取右半边的元素，否则2
2. 右半边是否用尽，如果用尽，取左半边的元素，否则3
3. 右半边的当前元素是否小于左半边的当前元素，如果是，取右半边的元素，否则取左半边的元素

```java
public static void merge(int[] arr, int low, int mid, int high){
    int left = low;
    int right = mid + 1;

    // 将数组复制到一个新的临时数组中
    int[] tempArr = new int[high+1];
    for (int i = low; i <= high; i++) {
        tempArr[i] = arr[i];
    }

    for (int i = low; i <= high; i++) {
        // 左半边是否用尽，如果用尽，取右半边的元素
        if ( left > mid ) arr[i] = tempArr[right++];

        // 右半边是否用尽，如果用尽，取左半边的元素
        else if ( right > high ) arr[i] = tempArr[left++];

        // 右半边的当前元素是否小于左半边的当前元素，如果是，取右半边的元素
        else if ( tempArr[right] < tempArr[left]) arr[i] = tempArr[right++];

        // 否则取左半边的元素
        else arr[i] = tempArr[left++];
    }

}
```

---

# 算法2.4 自顶向下的归并排序

```java
public static void mergeSort(int[] arr, int low, int high){
    if (high <= low ) return;

    // 找到中间点
    int mid = (low + high) / 2;

    // 排序左半边
    mergeSort(arr, low, mid);

    // 排序右半边
    mergeSort(arr, mid+1, high);

    // 左右两边归并
    merge(arr, low, mid, high);
}

public static void main(String[] args) {
    int[] testArr = {3,7,42,8,0,5, 66, 3, 80, 11, 2};
    System.out.println(Arrays.toString(testArr));

    mergeSort(testArr,0, testArr.length - 1);

    System.out.println(Arrays.toString(testArr));
}
```
