---
title: 数据库（二）高性能MySQL
comments: true
categories: 数据库
tags: SQL
abbrlink: 4c81d70
date: 2018-09-09 19:37:13
---

# 存储引擎

存储引擎是数据库的底层软件组织。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，可以获得其各自特定的功能。

## InnoDB

InnoDB 是 MySQL 默认的存储引擎，它是面向在线事务处理(OLTP)的应用，被设计用来处理大量的短期（short-lived）事务。

特点：
1. 采用 MVCC（多版本并发控制）来支持高并发
2. 支持事务，实现了 4 个事务隔离级别，默认级别是可重复读
3. 通过间隙锁（next-key locking）防止幻读，间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入
4. 基于聚簇索引，主键查询性能高，但二级索引（非主键索引）必须包含主键列，如果主键列很大，其他索引都会很大
5. 存储格式平台独立
6. 行锁设计
7. 支持外键
8. 支持一致性非锁定读（默认情况下读取操作不会产生锁）
9. 提供了插入缓冲，二次写，自适应哈希索引，预读等高性能和高可用的功能
10. 支持真正的热备份

一句话概括：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

## MyISAM

MyISAM 存储引擎表由 .MYD 和 .MYI 组成，.MYD用来存放数据文件，.MYI用来存放索引文件，特点：
- 不支持事务
- 表锁设计，读取共享锁，写入排他锁。但是在读取查询的同时也能插入记录（并发插入）
- 支持全文索引
- 压缩
- 空间函数（GIS）
- 它的缓冲池只缓冲索引文件，而不缓冲数据文件
- 崩溃后无法安全修复

一句话概括：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。如果表经常读取，且不需要事务，MyISAM是合适的选择。

## MEMORY

将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据库都将消失，它非常适合存储临时数据的临时表．默认采用哈希索引．

## 三种存储引擎的比较

![Engine](../../../../images/database/Engine.png)

<!-- more -->

---

# 索引

索引是一个单独存储在磁盘上的数据结构，它们 **包含着对数据表里所有记录的引用指针**。使用索引可以 **提高数据库特定数据的查询速度**。索引在存储引擎中实现。

索引的结构类型有两种：BTree 和 Hash table，具体和表的存储引擎有关。<font color="red">MyISAM和InnoDB存储引擎只支持 BTree</font>，MEMORY存储引擎索引可以支持 BTree 和 Hash table。

## 为什么要用索引？

一句话：提高查询效率

1. 唯一索引可以保证数据库表中每行数据的唯一性
2. 减少服务器需要扫描的数据量，加快数据的查询速度
3. 加速表和表之间的连接
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
5. 使用索引，可以在查询中使用优化隐藏器，提高系统的性能。
6. 将随机IO变为顺序IO

## 索引也有缺点

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加
2. 索引需要占空间内存
3. 在对表中数据进行增、删、改的时候，索引也需要动态维护，这样降低了数据维护速度

## B Tree 索引

InnoDB 和 MyISAM 底层都是基于 B+Tree 索引的。

### 适用于 B Tree 索引的情况

1. **全值匹配**：索引可能有多个列，全值匹配就是匹配所有的列。例如，查找姓名列为 Allen，年龄列为 18 的人。
2. **匹配最左前缀**：匹配所有姓 Allen 的人。即只使用索引的第一列。
3. **匹配列前缀**：匹配某一列的值的开头部分。例如姓以 Al 开头的人。也只使用了索引的第一列。
4. **匹配范围值**：匹配查找姓在 Allen 和 Barrymore 之间的人。也只使用索引的第一列。
5. **精确匹配某一列并范围匹配另外一列**：查找所有姓为 Allen，并且名字是 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。
6. **只访问索引的查询**：查询只需要访问索引，而无需访问数据行。（覆盖索引）

### 不适用于 B Tree 索引的情况

1. **非最左**：不是按照索引的最左列开始查找，就无法使用索引。例如无法查找姓氏（姓氏是索引的第一列）不知道，但名字（名字是索引第二列）为 Bill 的人。也无法查找姓氏最后以 n 结尾的人，因为姓氏虽然是第一列，但最左值不知道。
2. **跳过列**：不能按索引查找姓氏为 “Smith”（第一列），名字（第二列）不知道，年龄为 18 （第三列）的人。如果非要这样查找，那MySQL只会用到第一列姓氏的索引。
3. **某个列存在范围**：例如，姓氏为“Smith”，名字以“J”开头，年龄为18的SQL语句`... WHERE last_name = 'Smith' AND first_name like 'J%' AND age = 18;`，这时索引只有第一列姓氏起作用。

## 索引的分类

### 普通索引

```sql
CREATE INDEX indexName ON mytable(username(length));
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

### 唯一索引

索引列的值必须唯一，但允许有空值。如果要禁止空值，则成为主键索引。

```sql
CREATE UNIQUE INDEX indexName ON mytable(username(length))
```

### 组合索引

在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

MySql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。


### 全文索引

简单地说，全文索引就是在一堆文字中，通过其中的某个关键字等信息，就能找到该字段所属的记录行。

- **注意**：全文索引只有在 MyISAM 引擎上才能使用，且只能在CHAR,VARCHAR,TEXT类型字段上使用。

### 空间索引

空间索引是对空间数据类型的字段建立的索引。

传统的索引不能很好的索引空间数据，我们需要一种方法能对空间数据进行索引，例如专门对地图上景点数据的索引，这就是空间索引。

MySQL中的空间数据类型有四种：
- GEOMETRY （几何体）
- POINT （点）
- LINESTRING （线）
- POLYGON （多边形）

在创建空间索引时，使用SPATIAL关键字。当引擎为MyISAM，创建空间索引的列，必须将其声明为 NOT NULL。

## 什么时候该创建索引？

1. **主键**：对于主键，会自动建立一个唯一索引，以保证值唯一
2. **频繁查询**：对于频繁查询的表或字段，建立索引无疑会提高查询效率
3. **查询中需要排序的字段**：使用索引去访问排序字段将大大提高排序速度
4. **查询中需要统计或者分组字段**

## 什么时候不该使用索引？

1. 表记录太少
2. 经常增删改的字段（因为修改字段的同时还要动态维护索引）
3. WHERE 条件用不到的字段不需要索引
4. 过滤性不好的字段不适合使用索引，例如0/1，男/女

## 如何创建高性能的索引

### 1.独立的列

对于独立的列来说，要创建高效索引，必须满足：索引列不能是表达式的一部分，也不能是函数的参数。例如：

```sql
// 使用了表达式，索引失效
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;

SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(DATE_COL) <= 10;
```

应该养成简化 WHERE 条件的习惯，**始终将索引列放在比较符号的一侧**。

### 2.前缀索引

有时候要索引很长的字符列，这会让索引变得很大且慢。一种解决办法是在索引上再建哈希索引。但还可以用 **前缀索引** 来解决。

前缀索引，顾名思义，只索引字符串的前面一部分，例如，对于数据`University`，我们可以建立索引`Uni`。但这样会降低 **索引的选择性**，<font color="red">索引选择性是指不重复的索引值 和 表记录数的比值</font>。选择性越高，说明索引越多。唯一索引的选择性是1，因此性能最高。

在 MySQL 里面，BLOB、TEXT 和 很长的 VARCHAR 必须使用前缀索引。

查看前缀为3的情况

```sql
SELECT COUNT(*) AS cnt, LEFT(city, 3) AS pref
FROM city_demo
GROUP BY pref
ORDER BY cnt DESC LIMIT 10;
```

那索引前缀多长比较合适呢？诀窍是，**前缀应该足够长，使得选择性接近于整个列，但不能太长（以便节约空间）**。

计算完整列的选择性方法：
```sql
SELECT COUNT(DISTINCT city) / COUNT(*) FROM city_demo;
```

假如计算出来结果是 0.0312，那么选择性接近 0.0312 的前缀就差不多了。

测试各个前缀的选择性：

```sql
SELECT COUNT(DISTINCT LEFT(city, 3)) AS sel3,
       COUNT(DISTINCT LEFT(city, 4)) AS sel4,
       COUNT(DISTINCT LEFT(city, 5)) AS sel5
FROM city_demo;
```

当我们找到一个合适的前缀，比如是5，用下面的方式来创建前缀为5的前缀索引：

```sql
ALTER TABLE city_demo ADD KEY (city(5));
```

#### 前缀索引的缺点

无法使用前缀索引做 GROUP BY 和 ORDER BY 和 覆盖扫描。

### 3.多列索引

常见多列索引的错误有：为每一列创建独立的索引，或者按照错误的顺序创建索引。

那什么是正确的顺序呢？一个经验法则是：**当不需要考虑排序和分组时，将选择性最高的列放在最前面**。

一个简单的例子

```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```

创建索引时，是应该创建 (staff_id, customer_id) 还是 (customer_id,staff_id) ？这取决于哪一列的选择性更高。但这也不是绝对的，还要考虑WHERE 子句中的排序、分组、范围条件等其他因素。

### 4.聚簇索引

聚簇指的是：数据行和相邻的键值紧凑地存储在一起。当表有聚簇索引时，数据行存放在索引的叶子页。InnoDB的实现是，通过主键聚集数据，被索引的列就是主键列。

InnoDB支持聚簇索引，而MyISAM不支持，使用了聚簇索引和非聚簇索引的存储方式区别可见下面“索引的底层实现”的图。

如果没有主键，InnoDB会选择一个非空索引代替，如果没有这样的索引，就隐式创建一个。

聚簇索引优点：

- 把相关数据保存在一起
- 数据访问更快
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

聚簇索引缺点：

- 聚簇索引提高了I/O密集型应用的性能，但如果数据全部在内存中，那就没有优势
- 插入速度严重依赖于插入顺序
- 更新列代价高
- 页分裂问题，占用更多磁盘空间
- 全表扫描更慢
- 二级索引较大，访问要2次

#### 索引的底层实现

##### MyISAM 索引实现

MyISAM索引使用了 B+Tree 作为索引结构，叶子结点的 data 域<font color="red">存放的是数据记录的地址</font>。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。主索引和辅助索引的存储结构没有任何区别。

![MyISAM_index](../../../../images/SQL/MyISAM_index.png)

##### InnoDB 索引实现

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

InnoDB的数据文件本身就是索引文件。<font color="red">MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</font> 这种索引叫做聚簇索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据。

第二个与MyISAM索引的不同是InnoDB的 <font color="red">辅助索引data域存储相应记录主键的值而不是地址</font>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。


![InnoDB_index](../../../../images/SQL/InnoDB_index.png)

### 5.覆盖索引

正如聚簇索引中你看到的，索引本身是可以包含数据本身的，这样我们就不必回表查询，直接在索引拿到数据就行了。如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”，覆盖索引也不一定是聚簇索引，在MySQL中，只有 B Tree 索引能做覆盖索引。


## 什么时候索引会失效？

索引可以包含多个列的值，但是列的顺序十分重要，MySQL只能高效地使用索引的最左前缀列。

1. WHERE 条件有 不等于号
2. WHERE 条件使用了表达式或函数，如`SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;`
3. JOIN中，MySQL只有在 **主键和外键的数据类型相同** 时才能使用索引，否则无效
4. `LIKE ‘abc%’`，MYSQL将使用索引；但 `LIKE ‘%abc’`，MySQL将不使用索引。
5. 使用 OR 一般会使索引失效
6. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。

---

# 事务

## 什么是事务？

事务就是由一组SQL语句组成的逻辑处理单元，一个事务中的SQL语句组，要么全部执行，要么全部不执行。

```sql
START transaction;
SELECT ... FROM ...
UPDATE checking SET ...
DELETE savings FROM ...
COMMIT;
```

## 事务的自动提交（AUTOCOMMIT）

如果不显式开始一个事务，则每个查询都被当作一个事务执行提交操作。

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
SET AUTOCOMMIT = 1; // 1 或 ON 表示启用，0 或 OFF 表示禁用
```

## 事务的并发问题

1. **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. **幻读**：事务A在读取某个范围内的记录时，事务B又在该范围内插入新的记录，事务A再次读取该范围的记录时会产生幻行。（两次不一致）

不可重复读侧重于记录被修改，幻读侧重于新增或删除了记录。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

## 事务的四大特征

事务的四个基本特征可以概括为ACID：

1. **原子性（Atomicity）**：一个事务必须被视为不可分割的最小工作单元。一个事务中的所有操作，要么全部成功提交，要么全部失败回滚。不可能只执行其中的一部分操作。
2. **一致性（Consistent）**：在事务开始和完成时，数据都必须保持一致状态。不会出现查询开始时的数据跟查询到一半的数据不一样的情况。
3. **隔离性（Isolation）**：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着 <font color="red">事务处理过程中的中间状态对外部是不可见的，反之亦然。</font>事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
4. **持久性（Durability）**: 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务的隔离级别

事务的隔离级别规定了哪些修改在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离并发程度高，开销低。

1. **未提交读(Read uncommitted)**：事务中的修改，即使未提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为 **脏读**（Dirty Read）。该级别很少被使用。
2. **提交读(read committed)**：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的，这个级别有时候叫做不可重复读，因为同一事务自己两次执行同样的查询，期间可能有其他事务修改并提交了数据，因此两次查询可能会得到不一样的结果。
3. **可重复读(repeatable read)**：解决了脏读问题，该级别保证了在同一个事务中多次读同样记录的结果是一致的，理论上无法解决幻读问题。
4. **可串行化(Serializable)**:它通过强制事务串行执行，避免了前面说的幻读的问题。该级别用得较少。

MySQL 默认的事务隔离是第 3 级别，可重复读。

```sql
// 改变事务的隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 如何修改 MySQL 隔离级别

1. 查看当前会话隔离级别

```sql
select @@tx_isolation;
```

2. 查看系统当前隔离级别

```sql
select @@global.tx_isolation;
```

3. 设置当前会话隔离级别

```sql
set session transaction isolatin level repeatable read;
```

4. 设置系统当前隔离级别

```sql
set global transaction isolation level repeatable read;
```

---

# 锁

锁机制指的是，数据库为了保证数据的一致性而使各种共享资源在被并发访问时，让访问变得有序而设计的一种规则。解决的是并发问题。

锁的行为是存储引擎相关的，有些死锁是真正的数据冲突，而有些是存储引擎的实现导致的。

## 死锁问题

1. 解决一：InnoDB 存储引擎一旦检测到死锁的循环依赖，就会立即返回一个错误。具体做法是，将持有最少行级排他锁的事务进行回滚。
2. 解决二：当查询超时自动放弃锁请求，这种方式不太友好。

## 锁定级别

MySQL有三种级别的锁定。

### 表级锁定（table-level）

实现逻辑简单，带来的系统负面影响最小。获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发程度大打折扣。

### 页级锁定（page-level）

锁定颗粒度介于行级锁定与表级锁之间。页级锁定和行级锁定一样，会发生死锁。

### 行级锁定（row-level）

锁定颗粒度很小，发生锁定资源争用的概率也最小。能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。但由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。最容易发送死锁。

## 共享锁和排他锁

共享锁（shared lock）也叫做读锁，如果一个事务对数据对象A加了共享锁，其他事务只能读而不能写，直至当前事务释放该锁。


排他锁（exclusive lock）也叫做写锁，如果一个事务对数据对象A加了排他锁，其他事务不能再对A加锁，包括读和写，直至当前事务释放该锁。

## 乐观锁和悲观锁

悲观锁假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。而乐观锁假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁 **不能** 解决脏读的问题。<font color="red">所谓脏读，就是一个事务读取了另一个事务未提交的数据。</font>例如，事务T1更新了一行记录内容，但并没有提交修改。事务T2读取更新后的行，然后T1执行回滚操作。T2读取的行就无效了。

---

# 数据库三大范式

## 第一范式（1NF）

**属性不可分**。当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式的。

例如，某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就有必要要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。而“省份”、“城市”这些属性就是不可再分的了。

## 第二范式（2NF）

**符合1NF，并且表中的每列都和主键相关**。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说，在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

## 第三范式（3NF）

**符合2NF，并且，消除传递依赖**。即每一列数据都和主键直接相关，而不能间接相关。如学生信息和各科成绩，应该把成绩独立出来成为一张新表。

参考：https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html


## 范式化的优缺点

- 优点：更新操作快，没有冗余数据（意味着更少的GROUP BY和 DISTINCT），表数据通常较少可以更好地放进内存因此执行操作更快
- 缺点：需要关联，同时可能使某些索引失效

《高性能MySQL》中提到，实际中经常需要混用范式化和反范式化，不要极端地完全去范式化。

---

# 事务日志

事务日志用于提高事务效率。存储引擎修改表数据时，只需修改内存拷贝，然后把修改记录持久在硬盘的事务日志中，而不用每次都把修改的数据本身持久到硬盘中。之后把再内存修改的数据再慢慢刷回磁盘中。

---

# 多版本并发控制（MVCC）

MVCC 是行锁的变种，使用非阻塞读操作避免加锁，写操作也只锁定必要的行，因而开销更低。

**MVCC 是通过保存数据在某个时间点的快照来实现的**。不管事务执行多少时间，每个事务看到的数据都是一致的。

## InnoDB 的 MVCC 实现

在每行记录后面保存两个隐藏列。一个保存行的创建时间，一个保存行的过期时间（删除时间）。这里的时间，指的是系统版本号，不是真正的时间。每开始一个事务，系统版本号都会递增。

- **SELECT**：只查找早于当前版本的数据行，删除时间要么未定义，要么大于当前版本号。
- **INSERT**：为插入的行保存当前版本号。
- **DELETE**：为删除的行保存当前版本号，作为删除标志。
- **UPDATE**：先插入再删除。

MVCC的好处是读操作简单，性能好，不足是需要额外的存储空间和行检查、维护工作。

MVCC 只在提交读（READ COMMITTED）和可重复读（REPEATABLE READ）两个隔离级别下工作。

---

# MySQL Schema与数据类型优化

原则：
- **更小**：如果只要存0-200，tinyint unsigned比 int 好）
- **简单**：用内建类型表示时间而不是varchar
- **避免NULL**：有 NULL 的列使得索引、索引统计和值比较更加复杂。虽然调优时把NULL改NOT NULL性能提升较小，但是如果要在列上建索引，就应该避免 NULL

## CHAR 和 VARCHAR

- **CHAR**：定长字符串。会截断末尾的空格。适合存储较短的字符串或所有值长度接近。
- **VARCHAR**：可变长字符串。需要用1或2个额外字节记录字符串的长度。VARCHAR虽然节省空间性能较好，但UPDATE时由于长度的改变需要额外的工作。适用场景：字符串的最大长度比平均长度大很多，列很少更新。

需要注意的是，VARCHAR(5)和VARCHAR(200)存储 'hello'的空间开销是一样的，但是更长的列会消耗更多的内存，所以最好根据需要来分配。

## BLOB 和 TEXT

BLOB 和 TEXT 都是设计用来存储很大的字符串数据的，但 BLOB 采用二进制存储，TEXT采用字符方式存储。

跟其他类型不一样的是，当 BLOB 或 TEXT 值太大时，InnoDB会用专门的“外部”存储区来存储。每个值只需要在行内用1-4个字节存储指针，然后指向外部真正存储的区域。

- **BLOB**：二进制数据，没有排序规则，没有字符集
- **TEXT**：字符数据，有排序规则和字符集

在 MEMORY 存储引擎中不支持 BLOB 和 TEXT，如果使用到了，将不得不转换成 MyISAM 磁盘临时表，这将带来很大的开销。MEMORY中最好避免使用 BLOB 和 TEXT。

## 枚举类代替字符串

有时候可以用枚举类代替不重复的字符串。其内部是用整数实际存储的，而不是字符串。因此避免往里面插入常量（如'1','2'）避免混乱。但是也有缺点，添加或删除字符串需要用 `ALTER TABLE`，因此对于一些未来可能会改变的字符串，使用枚举是不明智的。

```sql
CREATE TABLE enum_test(
  e ENUM('fish','apple','dog') NOT NULL
);
INSERT INTO enum_test(e) VALUES ('fish', 'dog', 'apple');
```

## DATETIME 和 TIMESTAMP

- **DATETIME**：能保存1001年-9999年，精度为秒。将日期和时间封装到 YYYYMMDDHHMMSS 格式的整数中，与时区无关。使用8个字节的存储空间。
- **TIMESTAMP**：能保存1970-2038年，只使用4个字节，存储的是1970年1月1日到现在的秒数，时区相关。

## 其他

- MySQL 把 bit 当作字符串，而不是数字
- MySQL 内部使用整数存储 ENUM 和 SET 类型，比较时转换成字符串
- 应该用无符号整数存储IP地址，MySQL提供 `INET_ATON()` 和 `INET_NTOA()` 函数在整数和字符串表示方法之间转换

---

# MySQL 查询优化

## 查询慢的原因

1. **查询了不需要的记录**。一个典型的错误是先 SELECT 查出所有结果集，然后获取前面的 N 行后关闭结果。这样 N 行后面的数据就是不需要的数据，MySQL会把时间浪费在这上面。最好的解决办法是用 limit N，这样MySQL只会去找 N 行而不是所有。
2. **多表关联时返回全部列**。比如 `SELECT * FROM xxx join yyy ON ...`，其实可以用 `SELECT sakila.actor.* FROM sakila join yyy ON ... `，只取关键的列。
3. **总是取出全部列**。`SELECT *`的做法在数据库的角度是不考虑周全的，但是有时候从开发的角度看却能简化开发，因为能提高相同代码片段的复用性。
4. **重复查询相同的数据**。需要多次重复查询的数据，最好第一次查询后缓存起来，可以使用 redis 等。

## 切分查询

一次大查询（例如删除旧的数据）可能需要一次锁住很多数据，占满整个事务日志、耗尽系统资源、阻塞很多其他重要的查询。可以把大查询切分成很多个小查询。

```sql
// 原始 大查询
DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVEL 3 MONTH);

// 切分 小查询
rows_affected = 0;
do {
    rows_affected = do_query(
      "DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVEL 3 LIMIT 10000"
    )
} while rows_affected > 0;
```

## 分解关联查询

高性能应用都会对关联查询进行分解，先对每一个表进行单表查询，再将结果在应用程序进行关联。

```sql
// 分解前
SELECT * FROM tag
  JOIN tag_post ON tag_post.tag_id = tag.id
  JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = 'mysql';

//分解后
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post.id in (123,456,7897,9090)
```
