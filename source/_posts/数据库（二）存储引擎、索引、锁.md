---
title: 数据库（二）存储引擎、索引、锁
comments: true
categories: 数据库
tags: SQL
abbrlink: 4c81d70
date: 2018-09-09 19:37:13
---

# 存储引擎

存储引擎是数据库的底层软件组织。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，可以获得其各自特定的功能。

## InnoDB

InnoDB 是 MySQL 默认的存储引擎，它是面向在线事务处理(OLTP)的应用。特点：
- 支持事务
- 行锁设计
- 支持外键
- 支持一致性非锁定读（即默认情况下读取操作不会产生锁）
- 提供了插入缓冲，二次写，自适应哈希索引，预读等高性能和高可用的功能．

一句话概括：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

## MyISAM

MyISAM 存储引擎表由 MYD 和 MYI 组成，MYD用来存放数据文件，MYI用来存放索引文件，特点：
- 不支持事务
- 表锁设计
- 支持全文索引
- 它的缓冲池只缓冲索引文件，而不缓冲数据文件．

一句话概括：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。如果表经常读取，且不需要事务，MyISAM是合适的选择。

## MEMORY

将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据库都将消失，它非常适合存储临时数据的临时表．默认采用哈希索引．

## 三种存储引擎的比较

![Engine](../../../../images/database/Engine.png)

<!-- more -->

---

# 索引

索引是一个单独存储在磁盘上的数据结构，它们 **包含着对数据表里所有记录的引用指针**。使用索引可以提高数据库特定数据的查询速度。索引在存储引擎中实现。

索引的结构类型有两种：BTree 和 Hash table，具体和表的存储引擎有关。<font color="red">MyISAM和InnoDB存储引擎只支持 BTree</font>，MEMORY存储引擎索引可以支持 BTree 和 Hash table。

## 为什么要用索引？

一句话：提高查询效率

1. 唯一索引可以保证数据库表中每行数据的唯一性
2. 加快数据的查询速度
3. 加速表和表之间的连接
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
5. 使用索引，可以在查询中使用优化隐藏器，提高系统的性能。

## 索引也有缺点

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加
2. 索引需要占空间内存
3. 在对表中数据进行增、删、改的时候，索引也需要动态维护，这样降低了数据维护速度

## 索引的分类

### 普通索引

```sql
CREATE INDEX indexName ON mytable(username(length));
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

### 唯一索引

索引列的值必须唯一，但允许有空值。如果要禁止空值，则成为主键索引。

```sql
CREATE UNIQUE INDEX indexName ON mytable(username(length))
```

### 组合索引

在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

MySql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。


### 全文索引

简单地说，全文索引就是在一堆文字中，通过其中的某个关键字等信息，就能找到该字段所属的记录行。

- **注意**：全文索引只有在 MyISAM 引擎上才能使用，且只能在CHAR,VARCHAR,TEXT类型字段上使用。

### 空间索引

空间索引是对空间数据类型的字段建立的索引。

传统的索引不能很好的索引空间数据，我们需要一种方法能对空间数据进行索引，例如专门对地图上景点数据的索引，这就是空间索引。

MySQL中的空间数据类型有四种：
- GEOMETRY （几何体）
- POINT （点）
- LINESTRING （线）
- POLYGON （多边形）

在创建空间索引时，使用SPATIAL关键字。当引擎为MyISAM，创建空间索引的列，必须将其声明为 NOT NULL。

## 什么时候该创建索引？

1. **主键**：对于主键，会自动建立一个唯一索引，以保证值唯一
2. **频繁查询**：对于频繁查询的表或字段，建立索引无疑会提高查询效率
3. **查询中需要排序的字段**：使用索引去访问排序字段将大大提高排序速度
4. **查询中需要统计或者分组字段**

## 什么时候不该使用索引？

1. 表记录太少
2. 经常增删改的字段（因为修改字段的同时还要动态维护索引）
3. WHERE 条件用不到的字段不需要索引
4. 过滤性不好的字段不适合使用索引，例如0/1，男/女

## 什么时候索引会失效？

1. WHERE 条件有 不等于号
2. WHERE 条件使用了函数
3. JOIN中，MySQL只有在 **主键和外键的数据类型相同** 时才能使用索引，否则无效
4. `LIKE ‘abc%’`，MYSQL将使用索引；但 `LIKE ‘%abc’`，MySQL将不使用索引。
5. 使用 OR 一般会使索引失效
6. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。

## 索引的底层实现

### MyISAM 索引实现

MyISAM索引使用了 B+Tree 作为索引结构，叶子结点的 data 域<font color="red">存放的是数据记录的地址</font>。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。主索引和辅助索引的存储结构没有任何区别。

![MyISAM_index](../../../../images/SQL/MyISAM_index.png)

### InnoDB 索引实现

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

InnoDB的数据文件本身就是索引文件。<font color="red">MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</font> 这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据。

第二个与MyISAM索引的不同是InnoDB的 <font color="red">辅助索引data域存储相应记录主键的值而不是地址</font>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。


![InnoDB_index](../../../../images/SQL/InnoDB_index.png)

---

# 事务

事务是由一组SQL语句组成的逻辑处理单元。一个事务中的SQL语句组，要么全部执行，要么全部不执行。

## 事务的并发问题

1. **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. **幻读**：事务A在读取某个范围内的记录时，事务B又在该范围内插入新的记录，事务A再次读取该范围的记录时会产生幻行。（两次不一致）

不可重复读侧重于记录被修改，幻读侧重于新增或删除了记录。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

## 事务的基本特征

事务的四个基本特征可以概括为ACID：

1. **原子性（Atomicity）**
2. **一致性（Consistent）**：在事务开始和完成时，数据都必须保持一致状态
3. **隔离性（Isolation）**：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着 <font color="red">事务处理过程中的中间状态对外部是不可见的，反之亦然。</font>事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
4. **持久性（Durable）**: 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务的隔离级别

1. **未提交读(Read uncommitted)**：事务中的修改，即使未提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为 **脏读**。
2. **提交读(read committed)**：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的，这个级别有时候叫做不可重复读。这个级别上两次执行同样的查询会得到不一样的结果。
3. **可重复读(repeatable read)**：解决了脏读问题，该级别保证了在同一个事务中多次读同样记录的结果是一致的，理论上无法解决幻读问题。
4. **可串行化(Serializable)**:它通过强制事务串行执行，避免了前面说的幻读的问题。

MySQL 默认的事务隔离是第 3 级别，可重复读。

### 如何修改 MySQL 隔离级别

1. 查看当前会话隔离级别

```sql
select @@tx_isolation;
```

2. 查看系统当前隔离级别

```sql
select @@global.tx_isolation;
```

3. 设置当前会话隔离级别

```sql
set session transaction isolatin level repeatable read;
```

4. 设置系统当前隔离级别

```sql
set global transaction isolation level repeatable read;
```

---

# 锁

锁机制指的是，数据库为了保证数据的一致性而使各种共享资源在被并发访问时，让访问变得有序而设计的一种规则。解决的是并发问题。

## 锁定级别

MySQL有三种级别的锁定。

### 表级锁定（table-level）

实现逻辑简单，带来的系统负面影响最小。获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发程度大打折扣。

### 页级锁定（page-level）

锁定颗粒度介于行级锁定与表级锁之间。页级锁定和行级锁定一样，会发生死锁。

### 行级锁定（row-level）

锁定颗粒度很小，发生锁定资源争用的概率也最小。能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。但由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。最容易发送死锁。

## 共享锁和排他锁

共享锁（shared lock）也叫做读锁，如果一个事务对数据对象A加了共享锁，其他事务只能读而不能写，直至当前事务释放该锁。


排他锁（exclusive lock）也叫做写锁，如果一个事务对数据对象A加了排他锁，其他事务不能再对A加锁，包括读和写，直至当前事务释放该锁。

## 乐观锁和悲观锁

悲观锁假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。而乐观锁假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁 **不能** 解决脏读的问题。<font color="red">所谓脏读，就是一个事务读取了另一个事务未提交的数据。</font>例如，事务T1更新了一行记录内容，但并没有提交修改。事务T2读取更新后的行，然后T1执行回滚操作。T2读取的行就无效了。
