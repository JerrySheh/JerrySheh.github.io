---
title: 排序算法——优先队列和堆排序
comments: true
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: 18ede324
date: 2018-04-12 14:07:12
---

有时候我们会收集一些元素，然后处理当前键值最大的元素。然后再收集更多，再处理。例如，在手机来电、短信、游戏三个程序中，来电的优先级是最高的，我们总希望先处理来电请求。

满足这种场景的数据结构，需要支持两种操作：**删除最大元素**、**插入元素**。这种数据类型，就叫`优先队列`。


<!-- more -->

---

# 初级实现

## 数组（无序）

我们可以用 [前面提到的](../../../../post/a7047cb5.html) 下压栈的方式来实现优先队列。 只是在其中加入一段内循环代码，将最大元素和栈顶元素交换，然后弹栈删除它。

## 数组（有序）

在**插入操作**中添加代码，将较大的元素往右边移动一格，以保证数组有序。这样，栈顶的元素永远是最大的，弹栈删除即可。

## 链表实现

可以用 [前面提到的](../../../../post/a7047cb5.html) 基于链表的下压栈。 修改 `pop()` 找到并返回最大的元素， 或者修改 `push()` 保证所有元素逆序，并用 `pop()` 删除并返回链表的首元素（最大元素）。

---

# 堆

- **堆有序**：一棵二叉树的每个结点都**大于等于**它的两个子节点
- **二叉堆**：一组能够用堆有序的完全二叉树排序的元素，并在数组中按层级存储。

**二叉堆** 能够比初级实现更好地实现优先队列。

在一个堆中，位置 k 的父节点为 [k/2]，k 的两个子节点分别为 2k 和 2k+1

![k](../../../../images/DataStructure/k.png)

## 堆有序化


上浮法实现由下至上的堆有序化

```java
private void swim(int k){
    while( k>1 && less(k/2, k)){
        exch(k/2, k);
        k  = k/2;
    }
}
```

下沉法实现由上至下的堆有序化

```java
private void sink(int k){
    while (2*k <= N){
        int j = 2*k;
        if ( j<N && less(j,j+1))  j++;
        if ( !less(k,j)) break;
        exch(k,j);
        k = j;
    }
}
```

## 基于堆的优先队列

算法 2.6
```java
public class MapPQ<key extends Comparable<key>>{
    private key[] pq;
    private int N = 0;

    public MapPQ(int MaxN){
        pq = (key[]) new Comparable[maxN+1];
    }

    public boolean isEmpty(){
        return N == 0;
    }

    public int size(){
        return N;
    }

    public void insert(Key v){
        pq[++N] = v;
        swim(N);
    }

    public Key delMax(){
        Key max = pq[1];  //从根节点得到最大元素
        exch(1, N--);     //将其和最后一个结点交换
        pq[N+1] = null;   //防止对象游离
        sink(1);          //恢复堆有序
        return max;
    }
}
```

---

# 堆排序

基于优先队列的排序方法：将所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作，将他们按顺序删去。

堆排序就是一种这样的方法。分为两个阶段：
- 构造堆：将数组以堆的形式安排
- 下沉排序：按递减顺序取出所有元素，得到排序结果

算法2.7
```java
public static void sort(Comparable[] a){
    int N = a.length;
    for (int k=N/2; k>=1 ;k-- ) sink(a, k, N);

    while(N>1){
        exch(a, 1, N--);
        sink(a, 1, N);
    }
}
```

---

# 排序算法总结


算法 | 稳定性 | 原地 | 时间复杂度 | 空间复杂度 | 备注
---|---|---|---|---|---
选择排序|不稳定|是|N²|1|
插入排序|稳定|是|(N,N²)|1|取决于输入元素的排列情况
希尔排序|不稳定|是|NlogN ?|1|
快速排序|不稳定|是|NlogN|lgN|效率由概率提供保证
三向快速排序|不稳定|是|(N,NlogN)|lgN|
归并排序|稳定|否|NlogN|N|
堆排序|不稳定|是|NlogN|1|

> 快速排序是最快的通用排序算法。Java系统库中 java.util.Arrays.sort() 根据不同的类型参数使用了不同的排序方法。对于原始数据类型，Java选择了三向快速排序，而对于引用类型，则是用归并排序。这些选择实际上是用速度和空间来换取稳定性。
