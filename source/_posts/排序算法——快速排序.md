---
title: 排序算法——快速排序
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: a4803490
date: 2017-12-08 23:21:57
---

# 一、快速排序简介

在归并排序中，我们将一个数组分为两半，每一半又再分为两半，分到最后再一步步归并。

快速排序和归并排序是互补的：快速排序先选定一个元素，比这个元素小的放在左边，比这个元素大的放在右边，每一半，也都选一个元素，比它小的放左边，比它大的放右边。不断地选、分下去。

<!-- more -->

---

# 二、如何切分

假设我们选取数组的第一个元素为切分（partition）元素，那么我们如何把小于它的元素放在左边，大于它的元素放在右边呢？

1. 我们选取第一个元素 `a[low]` 为参考元素
2. 从左边向右，每一个元素都跟参考元素做比较，直到找到比参考元素小的
3. 从右边向左，每一个元素都跟参考元素做比较，直到找到比参考元素大的
4. 交换第 2，3 步 的两个元素
5. 重复 2、3、4，直到扫描完
6. 将参考元素`a[low]`放到中间位置

```java
//切分,将数组切分为a[low..i-1]、a[i]、a[i+1..high]
private static int partition(Comparable[] a, int low, int high){
    int i = low;
    int j = high +1;
    Comparable v = a[low]; // 将第一个元素选为参考元素
    while(true){
        //扫描左右，检查扫描是否结束并交换元素
        while (less(a[++i], v)) if ( i == high ) break;
        while (less(v, a[--j])) if ( j == low  ) break;
        if ( i >= j ) break;
        exch(a,i,j);
    }
    exch(a,low,j);  //将v=a[j]放入正确的位置
    return j;       //a[low..j-1] <= a[j] <= a[j+1..high]
}
```



---

# 三、算法2.5 快速排序


1. 先切分，再排序左半边，排序右半边
2. 排序左半边的时候，又会切分，排序左半边右半边，排序右半边的时候，也会切分，排序左半边右半边
3. 递归下去

```java
public class QuickSort {
    public static void main(String[] args) {
        Integer li[] = new Integer[10];
        Integer randomNum;
        for (int i = 0; i < 10; i++) {
            randomNum = (int) (Math.random()*100);
            li[i] = randomNum;
            System.out.print(li[i] + " ");
        }
        System.out.println("\n");

        sort(li,0,9);
        for (int i = 0; i < 10; i++) {
            System.out.print(li[i] + " ");
        }

    }

    private static void sort(Comparable[] a, int low, int high){
        if (high<=low) return;
        int j = partition(a, low, high); //切分,j是参考元素
        sort(a, low, j-1);         //将左半部分a[low..j-1]排序
        sort(a, j+1, high);         //将右半部分a[j+1..high]排序
    }
    //切分,将数组切分为a[low..i-1]、a[i]、a[i+1..high]
    private static int partition(Comparable[] a, int low, int high){
        int i = low;
        int j = high +1;
        Comparable v = a[low]; // 将第一个元素选为参考元素
        while(true){
            //扫描左右，检查扫描是否结束并交换元素
            while (less(a[++i], v)) if ( i == high ) break;
            while (less(v, a[--j])) if ( j == low  ) break;
            if ( i >= j ) break;
            exch(a,i,j);
        }
        exch(a,low,j);  //将v=a[j]放入正确的位置
        return j;       //a[low..j-1] <= a[j] <= a[j+1..high]
    }
    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }
    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
}
```
