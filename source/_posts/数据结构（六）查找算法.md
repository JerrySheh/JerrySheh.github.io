---
title: 数据结构（六）查找算法
comments: true
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: c61c7436
date: 2018-05-01 17:59:57
---

有时候我们需要检索信息，例如，找出某个元素在数组中的位置，或者找出某个集中是否有某个对象。寻找目标信息的过程，就叫查找。

[顺序查找](https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html) 和 [二分查找](https://algs4.cs.princeton.edu/11model/BinarySearch.java.html) 是查找的基本方法。

当我们需要高效查找时，我们可以用 **符号表（或者叫字典、索引）** 来表示一张抽象的表格。符号表的目的是将一个键和一个值联系起来。

**二叉查找树（或者叫二叉搜索树，Binary Search Tree, BST）**、**红黑树（基于平衡查找树, AVL）** 和 **哈希表（或者叫散列表）** 是三种经典的高效符号表。

<!--more-->

---

# 顺序查找和二分查找

## 顺序查找

顺序查找，简单地说就是遍历。从顺序表中逐个与目标值进行比对，直到找到匹配元素。

```java
public static int SequenceSearch(int[] arr, int key){

  for (int i = 0; i < arr.Length; i++){
      if (arr[i] == key){
          return i;
      }
  }
  return -1;
}
```

## 二分查找

先把一个序列从小到大排序，取中间元素与目标值进行比对，如果中间元素比目标值大，就在中间点左半边继续取中间点，否则在右半边取中间点。

![BinarySearch](../../../../images/DataStructure/BinarySearch.png)

```java
import java.util.Arrays;

public class BinarySearch {

    public static int binarySearch(int[] arr, int key){

        int low = 0;
        int high = arr.length -1;
        int mid;

        while (low <= high){
            // 每次调整后，中间值重新计算
            mid = (low + high) / 2;

            // 如果目标值大于中间值，将 low 调整到中间+1（下一次将查找右半边）
            if (key > arr[mid]) low = mid + 1;

            // 如果目标值小于中间值，将 high 调整到中间-1（下一次将查找左半边）
            else if (key < arr[mid]) high = mid - 1;

            // 如果目标值等于中间值，返回
            else return mid;
        }

        // 没有找到，返回 -1
        return -1;
    }

    public static void main(String[] args) {
        // 前提：数组一定要是有序
        int[] testArr = {3,4,8,10,11, 66, 80, 128};

        System.out.println(Arrays.toString(testArr));

        int result = binarySearch(testArr, 128);

        if ( result == -1 ) System.out.println("没有找到目标");
        else System.out.println("在数组下标 " + result + " 处找到目标");
    }
}
```


---

# 哈希

## 什么是哈希（Hash）？

Hash就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）。

这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一地确定输入值。简单的说，哈希就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。

## 哈希函数

哈希函数（散列函数）就是把键转换为数组的索引的过程。对于不同数据类型的键，有不同的哈希函数方法，例如：

- **正整数**：除留余数法（选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。简单地说，就是 k % M）
- **浮点数**：乘以M并四舍五入得到一个 [0,M-1] 之间的索引值。（但是这样做会让高位作用大，低位作用小，解决办法是将建转换成二进制然后用除留余数法）
- **字符串**：除留余数法
- **组合键**：组合除留余数

当然，除了除留余数法之外，还有直接定址法、数字分析法、平方取中法等来构造哈希函数，这里不展开讲。

在 Java 中，所有数据类型都继承了一个能够返回一个 32 Bits 整数的 `hashCode()` 方法。每种数据类型的 `hashCode()` 方法和 `equal()`方法必须一致。也就是说，`a.equal(b)`返回 true，那 `a.hashCode()` 和 `b.hashCode()` 必然一致。**但是反过来却不一定。**

## 哈希表（散列表）

哈希表是算法在时间和空间上作出权衡的经典例子。

我们知道，连续的存储结构——数组，在数据的查找和修改上具有很好的优点，很方便，时间复杂度很小。但是在数据的增添和删除上则显得很麻烦，空间复杂度很大。而非连续，非顺序的存储结构——链表，恰和数组相反，数据的增添和删除容易，空间复杂度很小，查找和修改复杂，时间复杂度很大。

而哈希表，既满足了数据的查找和修改很容易，同时又不占用很多空间的特点。

使用哈希的查找算法分为两步：

1. 用哈希函数将被查找的键转化为数组的一个索引
2. 处理碰撞冲突

> 为什么会碰撞冲突？因为不同的键通过哈希函数计算出来的值可能一样，比如，17%7=3，24%7=3，那对于键17和键24来说，他们的值都是3。也就是说，我们把键是17和键是24的数据都存储在了数组下标为3的地方，也就导致了碰撞冲突。

解决碰撞冲突的两种经典方法分别是：**拉链法** 和 **线性探测法**。

## 基于拉链法的哈希表

拉链法的处理方式是，将大小为 M 的数组中的每一个元素指向一条链表，链表中的每个节点都存储了哈希值为该元素索引的键值对。

查找分两步：

1. 根据哈希值找到链表；
2. 沿着链表顺序查找相应的键

![](../../../../images/DataStructure/hash.jpg)

> 可以拿我们生活的中的字典做比喻，比如我们要查找 “哈” 这个字，我们先去目录找到“哈”在 351 页。然后我们翻开第 351 页，发现这一页还有其他的比如"蛤"、“铪”等字，我们要在这一页中找到“哈”字所在的位置。

Java 实现

```java
public class SeparateChainingHashST<Key, Value>{
    private int N; //键值对总数
    private int M; //哈希表的大小

    // 存放链表对象的数组
    // SequentialSearchST是基于无序链表的顺序查找，实现见下面
    private SequentialSearchST<Key, Value>[] st;

    //无参构造函数
    public SeparateChainingHashST(){
        this(997); // 无参构造函数调用有参构造函数
    }

    //有参构造函数
    public SeparateChainingHashST(int M){
        //创建M条链表
        this.M = M;

        // JAVA不支持泛型数组，所以需要强制类型转换
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];

        for (int i=0; i<M ;i++ ) {
            st[i] = new SequentialSearchST();
        }
    }

    // 哈希函数：计算哈希值
    private int hash(Key key){
        return (key.hashCode() & 0x7ffffffff) % M;
    }

    //通过键获取值
    public Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }

    //修改某个键对应的内容
    public void put(Key key, Value val){
        st[hash(key)].put(key, val);
    }

    //哈希表中所有键的集合
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys())
                queue.enqueue(key);
        }
        return queue;
    }
}
```

- 基于拉链法的哈希表完整实现: [SeparateChainingHashST.java](https://algs4.cs.princeton.edu/34hash/SeparateChainingHashST.java.html)

## 引申：hashcode的作用

hashCode用于返回对象的散列值，用于在散列函数中确定放置的桶的位置。

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

2. 如果两个对象相同，就是适用于`equals(java.lang.Object)`方法，那么这两个对象的hashCode一定要相同；

3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于`equals(java.lang.Object)` 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

---

# 二叉查找树（二叉搜索树，BST）

// TODO

---

# 红黑树

// TODO
