---
title: 给自己的正则表达式备忘
categories: 技能
tags: linux
abbrlink: e36ce161
date: 2017-10-31 08:53:39
---

正则表达式（Regular Expression，在代码中常简写为 regex、regexp 或 RE），又称规则表达式，是计算机科学的一个概念。通常被用来检索、替换那些符合某个模式(规则)的文本。

<!-- more -->

---

# 正则表达式的基本规则

## 单个字符匹配

字符|规则|例子
---|---|---
\\|转义字符                    |`\(`表示左括号
.|匹配除了\\n之外的单个字符一次   | `a.c`
\\d|匹配一个数字，等同`[0-9]`       |`1\d8`匹配 138
\\D|匹配一个非数字                   | `1\d8`匹配 1A8
\\w|匹配一个字母、数字或下划线(w的意思是word)|
\\W|匹配一个非字母、数字或下划线         |
\\s | 匹配任何空白字符（空格、制表符、换页符等） |
\\S | 匹配任何非空白字符|
x &#124; y| 匹配x或者y（表达式）|
^|匹配行首                    | `^www`匹配以www开头
$|匹配行尾                    | `$com`匹配以com结尾
[^A-F]|取反                   |`[^A-F]`匹配A-F之外的字符

## 多个字符匹配

字符|规则|例子
---|---|---
[xyz]|匹配包含的任意一字符      |`a[xyz]b`，匹配 axb，ayb, azb
[a-z]|匹配指定范围内的任意字符    |`[0-9]`
* | 匹配前面的子表达式零次或多次| `zo*`，匹配z，zo，zoo
+ | 匹配前面的子表达式一次或多次| `zo+`，匹配zo，zoo
? | 匹配前面的子表达式零次或一次| `do(es)?`，匹配do，does
{n,m}|最少匹配n次，最多匹配m次|`(o{1,3})`，匹配foooood中的3个o
{n}|匹配确定的n次|`o{2}`，匹配food中的oo，不匹配fod中的o

## 分组匹配

可以用括号把要匹配的内容分组，例如匹配带区号的电话号码，可以把区号和电话分组。这样更容易看。

字符|规则|例子
---|---|---
() |分组 |`(\d{3,4})\-(\d{6,8})`
(&#124;)|分组和或的组合| hello\\s(world&#124;ketty&#124;jerry)

分组还有一个好处，当你想使用正则替换时，可以用 `$1`、`$2` 来表示第几组的内容。例如，在 Java 中为匹配到的内容前后分别加 `<b> </b>` :

```java
s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
```

## 非贪婪匹配

假设要求 1230000 后面有几个零，正则为 `(\d+)(0*)`，但是却发现第一组匹配到 1230000，第二组匹配到空白。我们期望的是第一组匹配到 123，第二组匹配到 0000。

此时可以在第一组末尾加 `?` 表示非贪婪匹配，如：`(\d+?)(0*)`，这样第一组就会少匹配，第二组多匹配。

而对于 `(\d??)(9*)`， 匹配 9999 时，第一组匹配到空白，第二组匹配到 9999。因为第一个问号表示零次或一次，第二个问号表示非贪婪，正则表达式会按最少的零次来匹配。


## 匹配中文

匹配非ASCII字符，例如中文，用`\u####`的十六进制表示，例如：`a\u548cc`匹配字符串`a和c`，中文字符`和`的Unicode编码是548c。

---

# 进阶

## 零宽断言

零宽断言，指定的内容的前面或后面会出现满足指定规则的内容，而自己不占匹配位置。例如 `123abc` ，我想匹配 `123` 后面的内容`abc`，而不包括 `123` 本身。

字符|规则|例子
---|---|---
（?=pattern）| 匹配 pattern 前面的内容 | `\d(?=\sword)`， 从 `1 word` 中匹配到 `1`
（?<=pattern）| 匹配 pattern 后面的内容 | `(?<=num:)\d`， 从 `num:5` 中匹配到 `5`
(?!pattern) | 匹配非 pattern 前面的内容 | `i(?!k)` ，从 `wikipedia` 中匹配到不是`k`前面的`i`，即 wik**i**ped**i**a
(?<!pattern)| 匹配非 pattern 后面的内容|`(?<!k)i` ，从 `wikipedia` 中匹配到不是`k`后面的`i`，即w**i**kiped**i**a

---

# 一些实例

## 1.匹配以 Str 开头， r 结尾， 中间任意个任意字符

```
Str.*r
```

匹配到 Stringbuffer， StringBuilder

## 2. 匹配所有以 , 结尾，修改成 comment '',

```
查找：
(.*),

替换：
$1 comment '',
```

.表示任意字符，* 表示任意多个，括号用于在下面 $1 保留原内容

效果：
```
原：
not null,
NUMBER(20),

现：
not null comment '',
NUMBER(20) comment '',
```

## 3. 匹配所有以 [DEBUG] 开头，]] 或 yet 结尾，并且最后有换行符的，由于换行符在 Windows 为 CRLF ，在 Linux 为 LF，所以我们匹配1或2次，第一次 `\s` 匹配 CR，第二次匹配 LF 。

```
\[DEBUG\].*(\]\]|yet)(\s{1,2})
```

tips：用 `\` 来转义特殊符号，如匹配 `[` ，要输入 `\[`

## 4. 匹配16进制数

```
[0-9a-fA-F]
```

## 5. Linux中使用 grep 和正则表达式，查找文件

```
grep -E --color '[xyz]' filename
```

---

# 一些有用的网站

- [正则可视化](https://regexper.com/)
- [正则验证和可视化](https://regexr.com/)

---

# 参考

- [廖雪峰教程](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945288020320)
- [知乎：你是如何学会正则表达式的？](https://www.zhihu.com/question/48219401)
