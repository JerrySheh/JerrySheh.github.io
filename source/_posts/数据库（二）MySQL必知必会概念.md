---
title: 数据库（二）MySQL必知必会概念
comments: true
categories: 数据库
tags: SQL
abbrlink: 4c81d70
date: 2018-09-09 19:37:13
---

# 存储引擎

存储引擎是数据库的底层软件组织。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，可以获得其各自特定的功能。

## InnoDB

InnoDB 是 MySQL 默认的存储引擎，它是面向在线事务处理(OLTP)的应用，被设计用来处理大量的短期（short-lived）事务。

特点：
1. 采用 MVCC（多版本并发控制）来支持高并发
2. 支持事务，实现了 4 个事务隔离级别，默认级别是可重复读
3. 通过间隙锁（next-key locking）防止幻读，间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入
4. 基于聚簇索引，主键查询性能高，但二级索引（非主键索引）必须包含主键列，如果主键列很大，其他索引都会很大
5. 存储格式平台独立
6. 行锁设计
7. 支持外键
8. 支持一致性非锁定读（默认情况下读取操作不会产生锁）
9. 提供了插入缓冲，二次写，自适应哈希索引，预读等高性能和高可用的功能
10. 支持真正的热备份

一句话概括：InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。

## MyISAM

MyISAM 存储引擎表由 .MYD 和 .MYI 组成，.MYD用来存放数据文件，.MYI用来存放索引文件，特点：
- 不支持事务
- 表锁设计，读取共享锁，写入排他锁。但是在读取查询的同时也能插入记录（并发插入）
- 支持全文索引
- 压缩
- 空间函数（GIS）
- 它的缓冲池只缓冲索引文件，而不缓冲数据文件
- 崩溃后无法安全修复

一句话概括：MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。如果表经常读取，且不需要事务，MyISAM是合适的选择。

## MEMORY

将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据库都将消失，它非常适合存储临时数据的临时表．默认采用哈希索引．

## 三种存储引擎的比较

![Engine](../../../../images/database/Engine.png)

<!-- more -->

---

# 索引

索引是一个单独存储在磁盘上的数据结构，它们 **包含着对数据表里所有记录的引用指针**。使用索引可以 **提高数据库特定数据的查询速度**。索引在存储引擎中实现。

索引的结构类型有两种：BTree 和 Hash table，具体和表的存储引擎有关。<font color="red">MyISAM和InnoDB存储引擎只支持 BTree</font>，MEMORY存储引擎索引可以支持 BTree 和 Hash table。

## 为什么要用索引？

一句话：提高查询效率

1. 唯一索引可以保证数据库表中每行数据的唯一性
2. 减少服务器需要扫描的数据量，加快数据的查询速度
3. 加速表和表之间的连接
4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
5. 使用索引，可以在查询中使用优化隐藏器，提高系统的性能。
6. 将随机IO变为顺序IO

## 索引也有缺点

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加
2. 索引需要占空间内存
3. 在对表中数据进行增、删、改的时候，索引也需要动态维护，这样降低了数据维护速度

## B Tree 索引

InnoDB 和 MyISAM 底层都是基于 B+Tree 索引的。

### 适用于 B Tree 索引的情况

1. **全值匹配**：索引可能有多个列，全值匹配就是匹配所有的列。例如，查找姓名列为 Allen，年龄列为 18 的人。
2. **匹配最左前缀**：匹配所有姓 Allen 的人。即只使用索引的第一列。
3. **匹配列前缀**：匹配某一列的值的开头部分。例如姓以 Al 开头的人。也只使用了索引的第一列。
4. **匹配范围值**：匹配查找姓在 Allen 和 Barrymore 之间的人。也只使用索引的第一列。
5. **精确匹配某一列并范围匹配另外一列**：查找所有姓为 Allen，并且名字是 K 开头的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。
6. **只访问索引的查询**：查询只需要访问索引，而无需访问数据行。（覆盖索引）

### 不适用于 B Tree 索引的情况

1. **非最左**：不是按照索引的最左列开始查找，就无法使用索引。例如无法查找姓氏（姓氏是索引的第一列）不知道，但名字（名字是索引第二列）为 Bill 的人。也无法查找姓氏最后以 n 结尾的人，因为姓氏虽然是第一列，但最左值不知道。
2. **跳过列**：不能按索引查找姓氏为 “Smith”（第一列），名字（第二列）不知道，年龄为 18 （第三列）的人。如果非要这样查找，那MySQL只会用到第一列姓氏的索引。
3. **某个列存在范围**：例如，姓氏为“Smith”，名字以“J”开头，年龄为18的SQL语句`... WHERE last_name = 'Smith' AND first_name like 'J%' AND age = 18;`，这时索引只有第一列姓氏起作用。

## 索引的分类

### 普通索引

```sql
CREATE INDEX indexName ON mytable(username(length));
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

### 唯一索引

索引列的值必须唯一，但允许有空值。如果要禁止空值，则成为主键索引。

```sql
CREATE UNIQUE INDEX indexName ON mytable(username(length))
```

### 组合索引（多列索引）

在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

MySql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。


### 全文索引

简单地说，全文索引就是在一堆文字中，通过其中的某个关键字等信息，就能找到该字段所属的记录行。

- **注意**：全文索引只有在 MyISAM 引擎上才能使用，且只能在CHAR,VARCHAR,TEXT类型字段上使用。

### 空间索引

空间索引是对空间数据类型的字段建立的索引。

传统的索引不能很好的索引空间数据，我们需要一种方法能对空间数据进行索引，例如专门对地图上景点数据的索引，这就是空间索引。

MySQL中的空间数据类型有四种：
- GEOMETRY （几何体）
- POINT （点）
- LINESTRING （线）
- POLYGON （多边形）

在创建空间索引时，使用SPATIAL关键字。当引擎为MyISAM，创建空间索引的列，必须将其声明为 NOT NULL。

## 什么时候该创建索引？

1. **主键**：对于主键，会自动建立一个唯一索引，以保证值唯一
2. **频繁查询**：对于频繁查询的表或字段，建立索引无疑会提高查询效率
3. **查询中需要排序的字段**：使用索引去访问排序字段将大大提高排序速度
4. **查询中需要统计或者分组字段**

## 什么时候不该使用索引？

1. 表记录太少
2. 经常增删改的字段（因为修改字段的同时还要动态维护索引）
3. WHERE 条件用不到的字段不需要索引
4. 过滤性不好的字段不适合使用索引，例如0/1，男/女

## 索引的底层实现

### MyISAM 索引实现

MyISAM索引使用了 B+Tree 作为索引结构，叶子结点的 data 域<font color="red">存放的是数据记录的地址</font>。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。主索引和辅助索引的存储结构没有任何区别。

![MyISAM_index](../../../../images/SQL/MyISAM_index.png)

### InnoDB 索引实现

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

InnoDB的数据文件本身就是索引文件。<font color="red">MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。</font> 这种索引叫做聚簇索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据。

第二个与MyISAM索引的不同是InnoDB的 <font color="red">辅助索引data域存储相应记录主键的值而不是地址</font>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。


![InnoDB_index](../../../../images/SQL/InnoDB_index.png)


## 什么时候索引会失效？

索引可以包含多个列的值，但是列的顺序十分重要，MySQL只能高效地使用索引的最左前缀列。

1. WHERE 条件有 不等于号
2. WHERE 条件使用了表达式或函数，如`SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;`
3. JOIN中，MySQL只有在 **主键和外键的数据类型相同** 时才能使用索引，否则无效
4. `LIKE ‘abc%’`，MYSQL将使用索引；但 `LIKE ‘%abc’`，MySQL将不使用索引。
5. 使用 OR 一般会使索引失效
6. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。

---

# 事务

## 什么是事务？

事务就是由一组SQL语句组成的逻辑处理单元，一个事务中的SQL语句组，要么全部执行，要么全部不执行。

```sql
START transaction;
SELECT ... FROM ...
UPDATE checking SET ...
DELETE savings FROM ...
COMMIT;
```

## 事务的自动提交（AUTOCOMMIT）

如果不显式开始一个事务，则每个查询都被当作一个事务执行提交操作。

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';
SET AUTOCOMMIT = 1; // 1 或 ON 表示启用，0 或 OFF 表示禁用
```

## 事务的并发问题

1. **脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. **不可重复读**：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. **幻读**：事务A在读取某个范围内的记录时，事务B又在该范围内插入新的记录，事务A再次读取该范围的记录时会产生幻行。（两次不一致）

不可重复读侧重于记录被修改，幻读侧重于新增或删除了记录。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

## 事务的四大特征

事务的四个基本特征可以概括为ACID：

1. **原子性（Atomicity）**：一个事务必须被视为不可分割的最小工作单元。一个事务中的所有操作，要么全部成功提交，要么全部失败回滚。不可能只执行其中的一部分操作。
2. **一致性（Consistent）**：在事务开始和完成时，数据都必须保持一致状态。不会出现查询开始时的数据跟查询到一半的数据不一样的情况。
3. **隔离性（Isolation）**：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行。这意味着 <font color="red">事务处理过程中的中间状态对外部是不可见的，反之亦然。</font>事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
4. **持久性（Durability）**: 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务的隔离级别

事务的隔离级别规定了哪些修改在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离并发程度高，开销低。

1. **未提交读(Read uncommitted)**：事务中的修改，即使未提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为 **脏读**（Dirty Read）。该级别很少被使用。
2. **提交读(read committed)**：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的，这个级别有时候叫做不可重复读，因为同一事务自己两次执行同样的查询，期间可能有其他事务修改并提交了数据，因此两次查询可能会得到不一样的结果。
3. **可重复读(repeatable read)**：解决了脏读问题，该级别保证了在同一个事务中多次读同样记录的结果是一致的，理论上无法解决幻读问题。
4. **可串行化(Serializable)**:它通过强制事务串行执行，避免了前面说的幻读的问题。该级别用得较少。

MySQL 默认的事务隔离是第 3 级别，可重复读。

```sql
// 改变事务的隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 如何修改 MySQL 隔离级别

1. 查看当前会话隔离级别

```sql
select @@tx_isolation;
```

2. 查看系统当前隔离级别

```sql
select @@global.tx_isolation;
```

3. 设置当前会话隔离级别

```sql
set session transaction isolatin level repeatable read;
```

4. 设置系统当前隔离级别

```sql
set global transaction isolation level repeatable read;
```

---

# 锁

锁机制指的是，数据库为了保证数据的一致性而使各种共享资源在被并发访问时，让访问变得有序而设计的一种规则。解决的是并发问题。

锁的行为是存储引擎相关的，有些死锁是真正的数据冲突，而有些是存储引擎的实现导致的。

## 死锁问题

1. 解决一：InnoDB 存储引擎一旦检测到死锁的循环依赖，就会立即返回一个错误。具体做法是，将持有最少行级排他锁的事务进行回滚。
2. 解决二：当查询超时自动放弃锁请求，这种方式不太友好。

## 锁定级别

MySQL有三种级别的锁定。

### 表级锁定（table-level）

实现逻辑简单，带来的系统负面影响最小。获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发程度大打折扣。

### 页级锁定（page-level）

锁定颗粒度介于行级锁定与表级锁之间。页级锁定和行级锁定一样，会发生死锁。

### 行级锁定（row-level）

锁定颗粒度很小，发生锁定资源争用的概率也最小。能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。但由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。最容易发送死锁。

## 共享锁和排他锁

共享锁（shared lock）也叫做读锁，如果一个事务对数据对象A加了共享锁，其他事务只能读而不能写，直至当前事务释放该锁。


排他锁（exclusive lock）也叫做写锁，如果一个事务对数据对象A加了排他锁，其他事务不能再对A加锁，包括读和写，直至当前事务释放该锁。

## 乐观锁和悲观锁

悲观锁假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。而乐观锁假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁 **不能** 解决脏读的问题。<font color="red">所谓脏读，就是一个事务读取了另一个事务未提交的数据。</font>例如，事务T1更新了一行记录内容，但并没有提交修改。事务T2读取更新后的行，然后T1执行回滚操作。T2读取的行就无效了。

---

# 数据库三大范式

## 第一范式（1NF）

**属性不可分**。当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式的。

例如，某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就有必要要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。而“省份”、“城市”这些属性就是不可再分的了。

## 第二范式（2NF）

**符合1NF，并且表中的每列都和主键相关**。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说，在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

## 第三范式（3NF）

**符合2NF，并且，消除传递依赖**。即每一列数据都和主键直接相关，而不能间接相关。如学生信息和各科成绩，应该把成绩独立出来成为一张新表。

参考：https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html


## 范式化的优缺点

- 优点：更新操作快，没有冗余数据（意味着更少的GROUP BY和 DISTINCT），表数据通常较少可以更好地放进内存因此执行操作更快
- 缺点：需要关联，同时可能使某些索引失效

《高性能MySQL》中提到，实际中经常需要混用范式化和反范式化，不要极端地完全去范式化。

---

# 事务日志

事务日志用于提高事务效率。存储引擎修改表数据时，只需修改内存拷贝，然后把修改记录持久在硬盘的事务日志中，而不用每次都把修改的数据本身持久到硬盘中。之后把再内存修改的数据再慢慢刷回磁盘中。

---

# 多版本并发控制（MVCC）

MVCC 是行锁的变种，使用非阻塞读操作避免加锁，写操作也只锁定必要的行，因而开销更低。

**MVCC 是通过保存数据在某个时间点的快照来实现的**。不管事务执行多少时间，每个事务看到的数据都是一致的。

## InnoDB 的 MVCC 实现

在每行记录后面保存两个隐藏列。一个保存行的创建时间，一个保存行的过期时间（删除时间）。这里的时间，指的是系统版本号，不是真正的时间。每开始一个事务，系统版本号都会递增。

- **SELECT**：只查找早于当前版本的数据行，删除时间要么未定义，要么大于当前版本号。
- **INSERT**：为插入的行保存当前版本号。
- **DELETE**：为删除的行保存当前版本号，作为删除标志。
- **UPDATE**：先插入再删除。

MVCC的好处是读操作简单，性能好，不足是需要额外的存储空间和行检查、维护工作。

MVCC 只在提交读（READ COMMITTED）和可重复读（REPEATABLE READ）两个隔离级别下工作。

---
