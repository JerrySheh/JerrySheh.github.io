---
title: 背包、队列、栈和链表
date: 2017-11-23 23:06:46
tags: 数据结构和算法
---

<!--

<font color=#FF0000 >
</font>

<b> </b>

-->
# 数据抽象

在谈数据结构之前，先聊一聊什么是`数据抽象`和`抽象数据类型（ADT）`。

数据类型是指一组`值`和一组对这些值的`操作`的集合，JAVA中有多种`原始数据类型`，如int。int是 -2^31 到 2^31 - 1 之间的这些整数值，以及+、-、\*、/ 等这些操作的集合。理论上所有程序只需要使用这些原始数据类型(int double char等)即可，但是如果把原始数据类型抽象成更高级的数据类型（string queue stack等），会方便我们编写程序。<b>我们把定义和使用我们自己的数据类型的这个过程，叫做数据抽象。</b>

抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。它将数据和函数的实现关联，并将数据的表示方式隐藏起来。我们在使用抽象数据类型时，主要关注如何操作而不关心数据本身是怎么表示的。也就是说，使用一个抽象数据类型，并不需要了解其实现细节。

![ADT](../../../../images/ADT.png)
---

<!-- more -->


# 三种集合类数据类型简介

## 1. 背包

背包是一种不支持从中删除元素的集合数据类型。它主要用于帮助用例收集元素，然后遍历这些的元素。这些元素没有顺序。


## 2. （先进先出）队列

队列是一种先进先出（FIFO）策略的集合类型。


## 3. 栈

栈是一种后进先出（LIFO）策略的集合类型。

Dijkstra双栈算式表达式求值法，将操作数和运算符分别放入两个栈中，遇到左括号“（” 则忽略，遇到操作数则将操作数压入栈1中，遇到运算符将它压入栈2中，遇到右括号，则弹出运算符和操作数，计算结果后重新压入栈中。


---

# 什么是游离

在一个栈中，当我们使用`pop()`弹栈的时候，被弹出的元素我们再也不需要用到它了。但它的引用还存在于数组中。这种情况就称为游离。

避免对象游离很容易，只需将其设为null即可。这样系统（JAVA垃圾回收策略）就可以在使用完后将起回收。

---


# 算法1.1 下压（LIFO）栈（能够动态调整数组大小的实现）

```JAVA
import java.util.Iterator;

public class ResizingArrayStack<Item> implements Iterable<Item> {
    private Item[] a = (Item[]) new Object[1];  //栈元素
    private int N = 0;                          //元素数量
    public boolean isEmpty(){ return N == 0; }
    public int size(){ return N; }

    private void resize(int max){               //将栈移动到一个大小为max的新数组
        Item[] temp = (Item[]) new Object[max];
        for (int i = 0; i < N; i++) {
            temp[i] = a[i];
        }
        a = temp;
    }

    public void push(Item item){               //将元素添加到栈顶
        if (N==a.length) resize(2*a.length);
        a[N++] = item;
    }

    public Item pop(){
        Item item = a[--N];
        a[N] = null;         //避免对象游离
        if ( N >0 && N == a.length/4) resize(a.length/2);
        return item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new ReverseArrayIterator();
    }

    public class ReverseArrayIterator implements Iterator<Item> {
        private int i = N;

        public boolean hasNext() {
            return i > 0;
        }

        public Item next() {
            return a[--i];
        }

        public void remove() {
        }
    }
}



```

---

# 什么是链表

链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。

## 1. 链表的实现

```java

private class Node{
  Item item;
  Node next;
}
```

## 2. 访问链表

如果有一个链表的对象实例 `first`，那么我们可以用 `first.item` 和 `first.next` 访问它的实例变量。


## 3. 构造链表

```java
//创建三个链表对象实例
Node first = new Node();
Node second = new Node();
Node third = new Node();

//每个实例的值
first.item = "to";
second.item = "be";
third.item = "or";

//指向下一个实例
first.next = second;
second.next = third;
```

我们先 new 了三个链表对象实例，然后给他们的Item赋值，并让他们的next指向下一个链表的引用。（链表是递归的数据结构）

在这里，`third.next`是null，也就是`third.next`指向了一个空链表。

链表表示的是一列元素。

## 4. 在表头插入结点

```java
//步骤一：保存原来的表头
Node oldfirst = first;

//步骤二：创建新的首结点
first = new Node();

//步骤三：设置新结点的实例变量
first.item = "not";
first.next = oldfirst;
```

## 5. 删除头结点

```java
first = first.next;
```

## 6. 在表尾插入结点

```java

//步骤一：保存指向尾结点的链接
Node oldlast = last;

//步骤二：创建新的尾结点
last = new Node();
last.item = "not";

//步骤三：将尾链接指向新结点
oldlast.next = last;

```

---

# 算法1.2 下压堆栈（链表实现）

```java
import java.util.Iterator;

public class Stack<Item> implements Iterable<Item>{
    private Node first;  //栈顶
    private int N;       // 元素数量
    private class Node{  //定义结点
        Item item;
        Node next;
    }

    public boolean isEmpty(){ return N == 0;}
    public int size(){ return N;}

    //向栈顶添加元素
    public void push(Item item){
        Node oldfirst = first;
        first = new Node();
        first.item = item;
        first.next = oldfirst;
        N++;
    }

    //从栈顶删除元素
    public Item pop(){
        Item item = first.item;
        first = first.next;
        N--;
        return item;
    }

    //实现迭代
    public Iterator<Item> iterator(){ return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext(){ return current != null; }
        public void remove(){ }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}




```

---

# 算法1.3 先进先出队列(链表实现)

```java
import java.util.Iterator;

public class Queue<Item> {
    private Node first;  //指向最早添加的结点的链接
    private Node last;   //指向最近添加的结点的链接
    private int N;       // 元素数量
    private class Node{  //定义结点
        Item item;
        Node next;
    }

    public boolean isEmpty(){ return first == null;}
    public int size(){return N;}

    //向表尾添加元素
    public void enqueue(Item item){
        Node oldlast = last;
        last = new Node();
        last.item = item;
        last.next = null;
        if (isEmpty()) first = last;
        else oldlast.next = last;
        N++;
    }

    //从表头删除元素
    public Item dequeue(){
        Item item = first.item;
        first = first.next;
        if (isEmpty()) last = null;
        N--;
        return item;
    }

    //实现迭代
    public Iterator<Item> iterator(){ return new ListIterator(); }
    private class ListIterator implements Iterator<Item>{
        private Node current = first;
        public boolean hasNext(){ return current != null; }
        public void remove(){ }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
}

```
