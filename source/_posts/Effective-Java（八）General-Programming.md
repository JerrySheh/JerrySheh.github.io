---
title: Effective Java（八）General Programming
comments: true
abbrlink: 7d5810ff
date: 2019-11-14 21:55:19
categories: Effective Java
tags: Java
---

# Item 57 最小化局部变量的作用域

> 好的编程习惯：在首次使用的地方声明它。

1. 如果循环终止后不需要循环变量的内容，那么优先选择 for 循环而不是 while 循环。
2. 如果变量需要在 `try-catch` 之外使用，那就必须在外面提前声明，这是一个例外。其他情况都应该遵循在首次使用的地方声明。
3. 每个行为对应一个方法。保持方法小而集中。

---

# Item 58 for-each 循环优于 fori 循环

如果你只是需要容器里的元素，而不需要下标，fori循环显然增加出错的可能性。最好用 for-each。for-each还可以用来遍历实现 Iterable 接口的任何对象。

但也有不能用for-each的情况：

1. **过滤删除**：如果需要遍历集合，并删除指定选元素，则需要使用显式iterator，以便可以调用其 remove 方法。 通常可以使用在 Java 8 中添加的 Collection 类中的 removeIf 方法，来避免显式遍历。
2. **转换**：如果需要遍历一个列表或数组并替换其元素的部分或全部值，那么需要列表迭代器或数组索引来替换元素的值。
3. **并行迭代**

---

# Item 59 了解并使用库

通过使用标准库，你可以利用编写它的专家的知识和以前使用它的人的经验。

例如，生成随机数，自己写有很大的不确定性，但是直接使用 `Random.nextInt(int)` 可以直接得到期望的结果。Java 7 更应该用 `ThreadLocalRandom`，它能产生更高质量的随机数，而且速度比`Random`快。对于 fork 连接池和并行流，使用 `SplittableRandom`。

每个程序员都应该熟悉 java.lang、java.util 和 java.io 的基础知识及其子包。其他库的知识可以根据需要学习。此外，Collections 框架和 Streams 库应该是每个程序员的基本工具包的一部分，`java.util.concurrent` 中的并发实用程序也应该是其中的一部分。

如果你在 Java 平台库中找不到你需要的东西，你的下一个选择应该是寻找高质量的第三方库，比如谷歌的优秀的开源 Guava 库 [Guava]。

不要重复造轮子！

---

# Item 60 精确数字就应避免 float 和 double ，使用 BigDecimal

《阿里巴巴Java开发手册》提到：

> 【强制】小数类型为 decimal ，禁止使用 float 和 double 。
> 说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

float 和 double 类型特别不适合进行货币计算。

```java
// 输出：0.6100000000000001
System.out.println(1.03 - 0.42);
```

使用 BigDecimal 能解决这个问题，注意：**使用 BigDecimal 的 String 构造函数而不是它的 double 构造函数**。

```java
final BigDecimal TEN_CENTS = new BigDecimal(".10");
BigDecimal funds = new BigDecimal("1.00");
```

---

# Item 61 基本数据类型优于包装类

基本数据类型和其包装类两者之间有真正的区别！！自动装箱和自动拆箱模糊了基本类型和包装类型之间的区别，但不会消除它们的区别。

1. 基本类型只有它们的值，而包装类型有方法，引用，对象。
2. 基本类型只有值，而包装类型还能是 null。
3. 基本类型比包装类型更节省时间和空间。

如果你不小心的话，这三种差异都会给你带来真正的麻烦。例如，将 `==` 操作符应用于包装类型，这几乎都会带来错误。因为包装类同值可不同对象。

混合使用基本类型和包装类型，包装类型就会自动拆箱。如果一个空对象引用自动拆箱，将导致 `NullPointerException`。

还有一个问题，在 for 循环中声明包装类，可能会产生很多对象，或者反复装箱和拆箱，从而导致性能下降。

那什么时候应该用包装类呢？

1. **作为集合中的元素、键和值**：不能将基本类型放在集合中，因此必须使用包装类型。
2. **泛型**：不能将变量声明为 `ThreadLocal<int>` 类型，只能用 `ThreadLocal<Integer>`。
3. **反射**：在进行反射方法调用时，必须使用包装类型

---

# Item 62 当使用其他类型更合适时应避免使用字符串

略过

---

# Item 63 当心字符串连接引起的性能问题

不要使用 + 连接大量字符串，除非性能无关紧要。因为用 + 连接两个字符串时，本质上会复制这两个字符串的内容。一般这种需求最好使用 StringBuilder 的 append 方法。

---

# Item 64

未完待续
