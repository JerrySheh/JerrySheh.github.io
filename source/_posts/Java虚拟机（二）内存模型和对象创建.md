---
title: Java虚拟机（二）内存模型和对象创建
comments: true
date: 2018-08-04 19:51:52
categories: JAVA
abbrlink: 7a1af8ce
tags: Java
---

# 运行时数据区域

Java虚拟机（JVM）会在 Java 程序执行的过程中，把虚拟机所管理的内存划分为几个不同的数据区域。如下：

![](../../../../images/Java/JVM_Memory.png)

<!-- more -->

---

# 程序计数器（线程隔离）

类似于操作系统里的 PC 计数器，程序计数器可以看做是当前线程所执行的字节码的行号指示器。

如果线程正在执行的是一个 Java 方法，这个计数器 **记录的是正在执行的虚拟机字节码指令的地址**；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。

##  程序计数器的作用

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程中，程序计数器用于记录当前线程执行的位置，当线程被切换回来的时候能够知道该线程上次运行到哪儿了。


##  程序计数器的特点

1. 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。
2. 是一块较小的存储空间
3. 线程私有
4. 生命周期随着线程的创建而创建，随着线程的结束而死亡

---

# 虚拟机栈（栈内存）（线程隔离）

虚拟机栈描述的是 Java 方法执行的内存模型。

虚拟机栈是由一个个栈帧组成。每个 Java 方法即将执行的时候，JVM都会创建一个栈帧用于存储该方法的 **局部变量表、操作数、动态链接、方法出口等信息**。 每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。一个方法被调用了，即创建了一个“栈帧”，一个方法返回了，“栈帧”出栈，释放内存。

![VM_Stack](../../../../images/Java/VM_Stack.png)

### 1. 局部变量表

局部变量表用于存储方法参数和定义在方法体内的局部变量，包括各种基本数据类型，对象引用（reference）和 returnAddress。

### 2. 操作数栈

进行运算的地方

### 3. 动态链接

Java Class文件中有很多符号引用，一部分在类加载的时候转化为直接引用（称为静态链接），另一部分在每一次运行期间转化为直接引用，这部分被称为动态链接。

#### 符号引用和直接引用

符号引用是无歧义的可以定位到这个目标的字面量。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。

而直接引用可以理解为直接指向目标的指针。

在类加载的解析阶段，符号引用被转换为直接引用。

### 4. 方法出口

当一个方法执行的时候，只有两种可以退出方法的方法。第一种是JVM碰到任意一个方法返回的字节码指令，被称为正常完成出口。另一种是在执行方法中抛出异常并且未对异常进行处理，被称为异常完成出口。方法退出的时候相当于把栈帧出栈。


##  虚拟机栈的特点

1. 局部变量表随着栈帧的创建而创建，其大小在编译时期就已确定，创建时直接分配该大小的空间。方法运行过程中，局部变量表大小并不会改变。
2. 每个线程都有各自的Java虚拟机栈。生命周期随着线程的创建而创建，随着线程的结束而死亡。


## StackOverFlowError 和 OutOfMemoryError

虚拟机栈会抛出两种异常：

- **StackOverFlowError**： 表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。
- **OutOfMemoryError**： 当线程申请栈时发现栈已经满了，而且内存也全都用光了。

---

# 本地方法栈（线程隔离）

和Java虚拟机栈的作用类似，区别是：该区域服务的是 native 方法，而不是 Java 方法。

## 什么是本地方法？（Native方法）

Native 方法指的是 java 代码调用非 java 代码的接口。在 Java 中，被 `native` 关键字修饰的方法称为 Native 方法，Native 方法只在 Java 中声明，而具体实现是由其他编程语言实现的（比如C/C++）。

## JVM 如何让 Native Method 跑起来？

我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。

如果一个方法描述符内有 `native` ，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到 java 程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用 `java.system.loadLibrary()` 实现的。

---

# 堆内存（线程共享）

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

## 堆的特点

1. 堆内存是垃圾收集器管理的主要区域。
2. 堆内存是所有线程共享的。
3. 在虚拟机启动时创建。
4. 可以进一步细分为：新生代、老年代。新生代又可被分为：Eden、From Survior、To Survior。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。
5. 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出 OutOfMemoryError。

---

# 方法区（线程共享）

方法区用于 **存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

## 方法区的特点

1. 所有线程共享
2. 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。
3. 内存回收效率低：方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。对方法区的内存回收的主要目标是： **对常量池的回收** 和 **对类型的卸载**。

## 运行时常量池

运行时常量池是方法区的一部分。方法区就是借助运行时常量池来存储常量的。

一般我们声明常量的方式是：

```java
public class A{
  public static final double PI = 3.1415926;

  //...
}
```

这个类被编译后便生成class文件，这个类的所有信息都存储在这个class文件中。**当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中**。

![val_pool](../../../../images/Java/val_pool.png)

而且在运行期间，可以向常量池中添加新的常量。如：String类的 intern() 方法就能在运行期间向常量池中添加字符串常量。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。

---

# 直接内存

直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。

在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。

直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError

---

# 对象的创建过程

当虚拟机遇到 new 指令时，就会创建一个对象，过程如下：

1. **检查常量池**：是否有即将要创建的这个对象所属的类的符号引用，若没有，抛出`ClassNotFoundException`；
2. **检查符号引用所代表的类是否已经被JVM加载**：若还没有加载，则找到该类的 .class 文件并加载进方法区；
3. **准备所需的内存大小**：一个对象所需的内存大小是在这个对象所属类被定义完就能确定的，且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小；
4. **从堆中划分一块对应大小的内存空间给新的对象**：有 指针碰撞 和 空闲列表 两种方式；
5. **初始化**：为对象中的成员变量赋上初始值；
6. 设置对象头中的信息；
7. 调用对象的构造函数进行初始化。

---

# 访问对象的过程

引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式：

## 句柄访问方式

堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息。

引用类型的变量存放的是该对象在句柄池中的地址。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。


## 直接指针访问方式

引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。
但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。

## HotSpot虚拟机的做法

HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而性能比句柄访问方式快一倍。但它需要额外的策略存储对象在方法区中类信息的地址。
