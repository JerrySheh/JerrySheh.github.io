---
title: 数据结构（二）选择、插入、希尔排序算法
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: 7c5cf5e1
date: 2017-12-06 12:58:29
---

# 一、选择排序（Selection Sort）

## 选择排序介绍

选择排序是一种最简单的排序算法，它的算法步骤如下：
1. 找到数组中最小的元素
2. 将它和数组的第一个元素交换位置（如果相同，也交换）
3. 在剩下的元素中找到最小的元素
4. 将它和数组的第二个元素交换位置
5. 重复。。

选择排序交换的总次数为N，算法的效率取决于比较的次数。

特点： 运行时间和输入无关、移动数据是最少的

命题: 对于长度为 N 的数组，选择排序需要大约 N²/2次比较和 N 次交换

<!-- more -->

## 算法2.1 选择排序

```java

public class Selection {
    public static void sort(Comparable[] a){
        int N = a.length;
        for (int i = 0; i < N; i++){
            int min = i;
            for (int j = 0; j < N; j++) {
                if (less(a[j], a[min])) min = j;
            }
            exch(a, i, min);
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    //输出
    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}


```


---


# 二、插入排序（Insertion Sort）

## 插入排序介绍

插入排序，将数插入到其他已经有序的数中的适当位置。为了给要插入的数腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。

插入排序所需的时间取决于输入中元素的初始顺序。(原始数据越接近有序，越快)

命题：对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要约 N²/4 次比较以及 N²/4 次交换。最坏情况下需要 约 N²/2 次比较以及 N²/2 次交换，最好情况下需要 N-1 次比较 和 0 次交换。

## 算法2.2 插入排序

```java

public class Insertion {
    public static void sort(Comparable[] a){
        int N = a.length;
        for (int i = 1; i < N; i++) { //将a[i] 插入到 a[i-1]、a[i-2]...之中
            for (int j = i; j > 0 && less(a[j],a[j-1]); j--) {
                exch(a, j, j-1);
            }
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}


```

 ---

# 三、希尔排序（Shell Sort）

## 希尔排序介绍

在插入排序和选择排序中，由于它们只能交换相邻的元素，如果有位于数组起始的大元素，则需要多次遍历才能交换到队尾，很不划算。希尔排序以更大的间隔来比较和交换元素，这样，大元素在交换的时候，可以向右移动不止一个位置。

希尔排序只需要在插入排序的代码中将移动的元素距离由1改为h即可。

希尔排序依赖于间隔(step)的选取。


## 算法2.3 希尔排序


```java
public class Shell {
    public static void sort(Comparable[] a){
        int N = a.length;
        int h = 1;
        while(h < N/3) h = 3*h + 1;  // 1,4,13,40,121,364,1093...

        //将数组变为h有序
        while (h >= 1){
            //将a[i] 插入到 a[i-h]、a[i-2h]、a[i-3h]...之中
            for (int i = h; i < N ; i++) {
                for (int j = i; j > h && less(a[j],a[j-h]); j-=h) {
                    exch(a, j, j-h);
                }
            }
            h = h/3;
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}



```
