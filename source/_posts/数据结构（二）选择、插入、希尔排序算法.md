---
title: 数据结构（二）算法的复杂度、简单排序算法
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: 7c5cf5e1
date: 2017-12-06 12:58:29
---

# 前言：算法的复杂度

在讨论数据结构和算法时，我们通常用算法的复杂度来描述一个算法的好坏，复杂度包括：**时间复杂度** 和 **空间复杂度**。

## 时间复杂度

算法的时间复杂度，也就是算法的时间量度，记作：`T(n) = O(f(n))`。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称为算法的渐近时间复杂度，**简称为时间复杂度**。其中 f(n) 是规模 n 的某个函数。

### 如何推导时间复杂度

1. 用常数 1 取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在，且不是 1 ，则去除与这个项相乘的常数。

例如:

```c
int sum = 0, n = 100;   // 执行 1 次
sum = (1 + n) * n / 2;  // 执行 1 次
printf("%d", sum);      // 执行 1 次
```

这个算法的运行次数函数是 `f(n) = 3`。根据推导规则，第一步把常数项 3 改为 1。第二步保留最高阶项，它没有最高阶项，所以这个算法的时间复杂度为 `T(n) = O(1)`。

#### 常数阶

当 n = 1 时，算法执行次数为 3， 当 n = 100 时，算法的执行次数还是 3，所以我们可以看出这个算法的执行次数与 n 的规模没关系。我们把这种与问题的大小（n 的大小）无关，执行时间恒定的算法，叫作常数阶。

#### 线性阶

下面这段代码的时间复杂度为 `T(n) = O(n)`，因为循环体中的代码必须要执行 n 次。

```java
for (i = 0; i < n; i++) {
    /* 时间复杂度为 O(1) 的程序步骤序列 */
}
```

#### 对数阶

```java
int count = 1;
while (count < n) {
    count = count * 2;
    /* 时间复杂度为 O(1) 的程序步骤序列 */
}
```

由于每次 count 乘以 2 以后，就越来越接近于 n，也就是说有多少个 2 相乘后大于 n，则会退出循环。由` 2^x = n` 得到 ` x = log2n`。所以这个算法的时间复杂度为 `T(n) = O(logn)`。

#### 平方阶

```java
// 例1
int i, j;
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}

// 例2
int i, j， m;
for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
        /* 时间复杂度为 O(1) 的程序步骤序列 */
    }
}
```

在 例1 中内循环时间复杂度为`O(n)`，而对于外层的循环，不过是这个内循环再循环 n 次。所以这段代码的时间复杂度为 `O(n^2)`。

在 例2 中，时间复杂度就变为 O(m^n)

### 常见的时间复杂度耗费时间

从小到大依次是：

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

## 空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式：

```
S(n) = O(f(n))
```

其中 n 为问题的规模，`f(n)`为语句关于 n 所占存储空间的函数。

- 参考：[程序猿必修课之数据结构（二）算法和算法的复杂度](https://www.jianshu.com/p/d72d4c9e90c6)

---

# 一、选择排序（Selection Sort）

## 选择排序介绍

选择排序是一种最简单的排序算法，它的算法步骤如下：
1. 找到数组中最小的元素
2. 将它和数组的第一个元素交换位置（如果相同，也交换）
3. 在剩下的元素中找到最小的元素
4. 将它和数组的第二个元素交换位置
5. 重复。。

选择排序交换的总次数为N，算法的效率取决于比较的次数。

特点： 运行时间和输入无关、移动数据是最少的

命题: 对于长度为 N 的数组，选择排序需要大约 N²/2次比较和 N 次交换

<!-- more -->

## 算法2.1 选择排序

```java

public class Selection {
    public static void sort(Comparable[] a){
        int N = a.length;
        for (int i = 0; i < N; i++){
            int min = i;
            for (int j = 0; j < N; j++) {
                if (less(a[j], a[min])) min = j;
            }
            exch(a, i, min);
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    //输出
    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}


```


---


# 二、插入排序（Insertion Sort）

## 插入排序介绍

插入排序，将数插入到其他已经有序的数中的适当位置。为了给要插入的数腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。

插入排序所需的时间取决于输入中元素的初始顺序。(原始数据越接近有序，越快)

命题：对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要约 N²/4 次比较以及 N²/4 次交换。最坏情况下需要 约 N²/2 次比较以及 N²/2 次交换，最好情况下需要 N-1 次比较 和 0 次交换。

## 算法2.2 插入排序

```java

public class Insertion {
    public static void sort(Comparable[] a){
        int N = a.length;
        for (int i = 1; i < N; i++) { //将a[i] 插入到 a[i-1]、a[i-2]...之中
            for (int j = i; j > 0 && less(a[j],a[j-1]); j--) {
                exch(a, j, j-1);
            }
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}


```

 ---

# 三、希尔排序（Shell Sort）

## 希尔排序介绍

在插入排序和选择排序中，由于它们只能交换相邻的元素，如果有位于数组起始的大元素，则需要多次遍历才能交换到队尾，很不划算。希尔排序以更大的间隔来比较和交换元素，这样，大元素在交换的时候，可以向右移动不止一个位置。

希尔排序只需要在插入排序的代码中将移动的元素距离由1改为h即可。

希尔排序依赖于间隔(step)的选取。


## 算法2.3 希尔排序


```java
public class Shell {
    public static void sort(Comparable[] a){
        int N = a.length;
        int h = 1;
        while(h < N/3) h = 3*h + 1;  // 1,4,13,40,121,364,1093...

        //将数组变为h有序
        while (h >= 1){
            //将a[i] 插入到 a[i-h]、a[i-2h]、a[i-3h]...之中
            for (int i = h; i < N ; i++) {
                for (int j = i; j > h && less(a[j],a[j-h]); j-=h) {
                    exch(a, j, j-h);
                }
            }
            h = h/3;
        }
    }

    //比较两个数大小
    private static boolean less(Comparable v, Comparable w){
        return v.compareTo(w) < 0;
    }

    //交换两个数
    private static void exch(Comparable[] a, int i, int j) {
        Comparable swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }

    private static void show(Comparable[] a){
        for (int i = 0; i < a.length; i++) {
            StdOut.print(a[i] + " ");
        }
        StdOut.println();
    }
}



```
