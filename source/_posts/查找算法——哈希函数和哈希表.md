---
title: 查找算法——哈希函数和哈希表
comments: true
categories: 数据结构和算法
tags: 数据结构和算法
abbrlink: c61c7436
date: 2018-05-01 17:59:57
---

有时候我们需要高效地检索信息，也就是查找。我们可以用**符号表**（或者叫字典、索引）来表示一张抽象的表格。符号表的目的是将一个键和一个值联系起来。

[顺序查找](https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html)、二分查找是查找的基本方法。

二叉查找树、红黑树（基于平衡查找树）和哈希表（也叫散列表）是三种经典的高效符号表。

这一篇主要讲讲哈希表。

<!--more-->

---

# 哈希函数

哈希函数（散列函数）就是把键转换为数组的索引的过程。对于不同数据类型的键，有不同的哈希函数方法，例如：

- 正整数：除留余数法
- 浮点数：乘以M并四舍五入得到一个 [0,M-1] 之间的索引值。（但是这样做会让高位作用大，低位作用小，解决办法是将建转换成二进制然后用除留余数法）
- 字符串：除留余数法
- 组合键：组合除留余数

> 除留余数法：选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。简单地说，就是 k % M

当然，除了除留余数法之外，还有直接定址法、数字分析法、平方取中法等来构造哈希函数，这里不展开讲。

在 Java 中，所有数据类型都继承了一个能够返回一个 32 Bits 整数的 `hashCode()` 方法。每种数据类型的 `hashCode()` 方法和 `equal()`方法必须一致。也就是说，`a.equal(b)`返回 true，那 `a.hashCode()` 和 `b.hashCode()` 必然一致。**但是反过来却不一定。**

---

# 哈希表

哈希表是算法在时间和空间上作出权衡的经典例子。

我们知道，连续的存储结构——数组，在数据的查找和修改上具有很好的优点，很方便，时间复杂度很小。但是在数据的增添和删除上则显得很麻烦，空间复杂度很大。而非连续，非顺序的存储结构——链表，恰和数组相反，数据的增添和删除容易，空间复杂度很小，查找和修改复杂，时间复杂度很大。

而哈希表，既满足了数据的查找和修改很容易，同时又不占用很多空间的特点。

使用哈希的查找算法分为两步：

1. 用哈希函数将被查找的键转化为数组的一个索引
2. 处理碰撞冲突

> 为什么会碰撞冲突？因为不同的键通过哈希函数计算出来的值可能一样，比如，17%7=3，24%7=3，那对于键17和键24来说，他们的值都是3。也就是说，我们把键是17和键是24的数据都存储在了数组下标为3的地方，也就导致了碰撞冲突。

解决碰撞冲突的两种经典方法分别是：**拉链法** 和 **线性探测法**。

## 基于拉链法的哈希表

拉链法的处理方式是，将大小为 M 的数组中的每一个元素指向一条链表，链表中的每个节点都存储了哈希值为该元素索引的键值对。

查找分两步：

1. 根据哈希值找到链表；
2. 沿着链表顺序查找相应的键

![](../../../../images/DataStructure/hash.jpg)

> 可以拿我们生活的中的字典做比喻，比如我们要查找 “哈” 这个字，我们先去目录找到“哈”在 351 页。然后我们翻开第 351 页，发现这一页还有其他的比如"蛤"、“铪”等字，我们要在这一页中找到“哈”字所在的位置。

Java 实现

```java
public class SeparateChainingHashST<Key, Value>{
    private int N; //键值对总数
    private int M; //哈希表的大小

    // 存放链表对象的数组
    // SequentialSearchST是基于无序链表的顺序查找，实现见下面
    private SequentialSearchST<Key, Value>[] st;

    //无参构造函数
    public SeparateChainingHashST(){
        this(997); // 无参构造函数调用有参构造函数
    }

    //有参构造函数
    public SeparateChainingHashST(int M){
        //创建M条链表
        this.M = M;

        // JAVA不支持泛型数组，所以需要强制类型转换
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];

        for (int i=0; i<M ;i++ ) {
            st[i] = new SequentialSearchST();
        }
    }

    // 哈希函数：计算哈希值
    private int hash(Key key){
        return (key.hashCode() & 0x7ffffffff) % M;
    }

    //通过键获取值
    public Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }

    //修改某个键对应的内容
    public void put(Key key, Value val){
        st[hash(key)].put(key, val);
    }

    //哈希表中所有键的集合
    public Iterable<Key> keys() {
        Queue<Key> queue = new Queue<Key>();
        for (int i = 0; i < m; i++) {
            for (Key key : st[i].keys())
                queue.enqueue(key);
        }
        return queue;
    }
}
```

- 基于无序链表的顺序查找实现：[SequentialSearchST.java](https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html)
- 基于拉链法的哈希表完整实现: [SeparateChainingHashST.java](https://algs4.cs.princeton.edu/34hash/SeparateChainingHashST.java.html)

---


# 引申：hashcode的作用

hashCode用于返回对象的散列值，用于在散列函数中确定放置的桶的位置。

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

2. 如果两个对象相同，就是适用于`equals(java.lang.Object)`方法，那么这两个对象的hashCode一定要相同；

3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于`equals(java.lang.Object)` 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。
