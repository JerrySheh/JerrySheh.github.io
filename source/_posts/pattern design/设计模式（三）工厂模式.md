---
title: 设计模式（三）工厂模式
comments: true
categories: 设计模式
tags: 设计模式
abbrlink: c0765a5b
date: 2019-04-16 15:14:00
---

# 简单工厂模式

假设我们有一个发送机制，有两种发送模式：短信发送和邮件发送。具体要用哪种发送，由专门的工厂帮我们做就好，这就是工厂模式。

以消息发送为例，首先有一个发送接口

```java
public interface Sender {
    void send();
}
```

短信发送

```java
public class MessageSender implements Sender {
    @Override
    public void send() {
        System.out.println("Message sent !");
    }
}
```

邮件发送

```java
public class EmailSender implements Sender {
    @Override
    public void send() {
        System.out.println("Email sent !");
    }
}
```

我们是要发送邮件，还是发送短信，需要一个工厂来造。

<!-- more -->

```java
public class SenderFactory {

    // 造一个短信发送类
    public static Sender getMessageSender(){
        return new MessageSender();
    }

    // 造一个邮件发送类
    public static Sender getEmailSender(){
        return new EmailSender();
    }

}
```

测试类

需要邮件发送类，还是短信发送类，统一从工厂造

```java
public static void main(String[] args) {

    // need a Email Sender
    Sender emailSender = SenderFactory.getEmailSender();
    emailSender.send();

    // need a Message Sender
    Sender messageSender = SenderFactory.getMessageSender();
    messageSender.send();

}
```

这就是简单的工厂模式了。我们使用静态方法定义简单工厂，称为静态工厂方法。静态工厂的好处是不需要创建工厂对象，但这样也有缺点：**不能通过继承来改变创建方法的行为**。

---

# 工厂方法模式（继承）

工厂方法模式定义了一个创建对象的接口，但由子类来决定要实例化的类是哪一个工厂方法让类把实例化推迟到子类。

---

# 抽象工厂模式（组合）

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

---

# 依赖倒置原则

高层组件不应该依赖于底层组件，底层也不应该依赖于高层。高层和底层应该都依赖于抽象。
