---
title: DailyQuestion
date: 2018-03-02 17:13:15
comments: false
---

# DAY 14

1. 类别：操作系统-综合
2. 面试问题：什么是缓冲区溢出？有什么危害？其原因是什么？
3. 技巧：缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，概念不难但是需要引申很多
4. 引申：缓冲区溢出的危害以及缓冲区溢出攻击

---

# DAY 13

1. 类别：计算机网络-综合
2. 面试问题：OSI与TCP/IP各层的结构与功能，都有哪些协议？
3. 技巧：概念基础题，但是理解了有助于对于计算机网络的整体理解
4. 引申：TCP等各层的协议以及作用，涉及到这些协议的一些概念性问题，例如：为什么直播使用UDP协议等


---

# DAY 12

1. 类别：操作系统-内存管理
2. 面试问题：内存内部碎片和外部碎片的区别？
3. 技巧：记清楚很容易，但是可以考虑做一些引申
4. 引申：虚拟内存. 内存管理方式等。

---

# DAY 11

1. 类别：操作系统-内存管理
2. 面试问题：内存的管理方式有哪些？段存储. 页存储. 段页存储介绍
3. 技巧：一定要分清分段和分页的异同
4. 引申：虚拟内存. 外部碎片和内部碎片等内存管理相关问题

---

# DAY 10

1. 类别：面试综合-项目
2. 面试问题：你在做xxx项目中遇到的最大困难是什么？
3. 技巧：和项目紧密相关，突出你觉得最有技术含量的，比如解决了什么关键问题，建议提前准备好（提前演练此问题，避免临场不知道说什么）。
4. 引申：项目架构. 项目的关键技术引申

---

# DAY 9

1. 类别：数据结构-二叉树
2. 面试问题：二叉树的镜像反转
3. 技巧：两种实现方式

方式一：递归：如果节点为空，返回，否则交换左右孩子指针；递归镜像节点的左子树，右子树；
方式二：非递归：交换每一非叶子节点的左子树指针和右子树指针 ，利用队列，根节点先入队；交换队列第一个节点的左右孩子之针，然后把第一个节点的左右孩子入队，然后pop();直到队列为空；即遍历完毕；

4. 引申：二叉树的各种遍历方式

---

# DAY 8

1. 类别：算法-基础算法
2. 面试问题：手写算法-单向链表的反转
3. 技巧：反转分为4步：

两个临时变量：当前节点curr和前一个节点prev

第一步：保存当前节点的下一个节点到tmp中；
第二步；将当前节点的下一个指向前一个；
第三步；将前一个prev指向指向当前节点curr；
第四步：将当前节点curr指向tmp，也就是实际上的下一个节点

4. 引申：链表的一系列操作手写算法

---

# DAY 7

1. 类别：计算机网络-TCP
2. 面试问题：说一说TCP的拥塞控制
3. 技巧：区分清楚拥塞控制和流量控制，讲清楚三个部分：慢启动，拥塞避免和快速回复
4. 引申：TCP流量控制等

当TCP发送方探测(如何探测？ACK超时和重复ACK)到网络拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况。

TCP协议通过`控制滑窗(sliding window)`大小来控制发送速率。滑窗大小取决于两个window

* **advertised window size** 实现流量控制。

* **congestion window size** 实现拥塞控制。

congestion window size总是处于两种状态的一个。这两种状态是: `慢起动(slow start)`和`堵塞避免(congestion avoidance)`。

总的来说，发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。

参考：

[协议森林12 天下为公 (TCP堵塞控制)](http://www.cnblogs.com/vamei/archive/2013/01/10/2850199.html)  

[TCP之旅](https://jerrysheh.github.io/post/e997edc6.html)

---

# DAY 6

1. 类别：设计模式—综合
2. 面试问题：你了解设计模式吗？介绍一种你常见的设计模式
3. 技巧：最好给出UML图和举例说明
4. 引申：实际开发中使用设计模式的例子. 好处等等，需要根据自己的项目中的一些例子来进行说明

---

# DAY 5

1. 类别：操作系统-进程
2. 面试问题：什么是死锁以及其产生的条件
3. 技巧：详述产生死锁的每个条件
4. 引申：怎样避免死锁，实际开发中的问题等等

死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

如

> 线程A：对lock a加锁 => 对lock b加锁 => dosth => 释放lock b => 释放lock a

> 线程B：对lock b加锁 => 对lock a加锁 => dosth => 释放lock a => 释放lock b

死锁产生的四个条件:互斥、等待/持有、非抢占、形成等待环

---

# DAY 4

1. 类别：计算机网络-综合
2. 面试问题：说一说浏览器键入URL之后的过程
3. 技巧：按流程说，越详细越好
4. 引申：Http协议和TCP协议等

参考：[当你输入一个网址的时候，实际会发生什么?
](https://jerrysheh.github.io/post/82216935.html)

---

# DAY 3

1. 类别：计算机网络-TCP和UDP
2. 面试问题：对TCP和UDP的理解，或者问区别
3. 技巧：有条理的详述各个区别，按区别来说，可以着重讲解TCP
4. 引申：TCP三次握手四次挥手，TCP有效连接的开始，TCP拥塞控制机制等

参考：[TCP与UDP的区别](https://jerrysheh.github.io/post/4399c62c.html)

---

# DAY 2

1. 类别：操作系统—进程线程
2. 面试问题：说一下进程与线程的区别
3. 技巧：有条理的详述各个区别，可以和面试官讲一讲自己的理解
4. 引申：进程间通信方式有哪些，多线程和多进程分别在什么时候采用

进程（Process）：一个操作系统任务就是一个进程。可以理解成正在进行中的程序。

线程（Thread）：在一个进程内部要同时运行多个“子任务”，这些“子任务”称为线程。

简单地说，一条线程指的是进程中一个单一顺序的控制流，而一个进程中可以并发多个线程，每条线程并行执行不同的任务。

多进程和多线程的本质区别在于，每个进程拥有自己的一套变量，而线程却共享数据。

参考：[Linux系统漫游（二）从进程到并发](https://jerrysheh.github.io/post/9cf7e81b.html)

---

# DAY 1

lost
